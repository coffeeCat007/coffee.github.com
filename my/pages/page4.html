<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>项目与问题</title>
</head>
<body>
	<h1>项目与问题</h1>
	<p>
		1.1.display2.宽高3.bgc4.最后选择标准或者浮动，或者定位模式估计数字，网页调整。5.font
2.元素脱标会在z轴上有数值。z-index设置值的顶部高度。
3.网页中使用img还是bgi，页面中都是字符串，请求服务器，下载，客户端解析，呈现页面，字节越小，网速越快，这是一个，后台可以生成。使用bgi。
4.记得定位除了数值位置，还有center，top这些方位属性。
5.position：absoluted；下方，设置top：0px、left：0px与默认设置是不同的效果，设置了00，以浏览器为坐标，不设置以父元素为坐标，导致，最终位置是不同的。
6.两个标签的覆盖：伪类中使用：after，元素显现是在最后的，可以覆盖，使用before，呈现在最前，可以被覆盖。
6.div的叫法：标准叫层，通俗叫盒子，实际上，div里面的标签是在div上面叠着。
7.使用z-index的方法
8.li中的a使用技巧：li设置行高，一般来说，a值设置颜色字体，宽高是li标签的来设置。
9.span的使用技巧：一般用来使用标点符号的样式。
10.color：标注叫前景色
11.100xx%百分之多少，指的是父级元素的百分之多少
12.等级太低的话，选择三个字母起类名，不要太少了，难以找到。
13.协议不跳转，轮播图。
14.基础的知识，一定要打牢，面试也工作都要用。
15.div+css布局，就是注释加类名加盒子。
16.最大的盒子，以及包含盒子多的大盒子，就不要使用撑开来呈现盒子的宽高。
17.用户信息的头像就是img
----------------------------------------------------------------------------------
js
1.代码遇到问题，优先调试。
2.命名规范：英文或者拼音的全拼。
3.注重基础，以最简单的案例解决问题，以企业案例进行实践。
4.js有小bug，不要转牛角尖。
5.有疑问及时询问，或者积累。
6.三种注释：
7.异部与同步：
8.变量的声明与规范。
9.五大浏览器：谷歌，火狐，苹果，opera，ie。IE（8）最bug，牢记常见的浏览器的兼容问题。国产浏览器中的
佼佼者，就是uc，最重要的就是谷歌，ie，火狐。
10.浏览器中具有解析器：可以解析HTML，css，js。相当于一个翻译。
11.首先打开，看到的是用户界面，浏览器引擎处理，可以持久性存储数据，但是，长时间不适用，会被电脑清除
	其次，显示内容，解析css与html，都绘制出来的，浏览器所有显示出来的界面，都是绘制出来的、
12.浏览器的组件：
13.浏览器的工作原理：
14.javascript：
	ECMAScript：基本的语法与对象标准。
	DOM：文档编辑
	BOM：对象编辑
15.API就是一种方法，使用其他做出来的成果，放置在自己的程序中，就可以显示实现自己的功能。
16.程序本来是要编写代码，在进行进制编译，才能识别，现用的都是高级编程语言，最高级的编程语言
	就是c语言， 编译就是高级编程语言转化成为计算机语言，我们学习的js是不需要编译的，是一门
	脚本语言，这就是js的脚本原理。c#，java，ios三种语言大同小异。在计算机里面计算机存储
	具有一定的限制。
17.认知当前的变量到底是什么类型。脚本（不编译，直接运行在命令行中），弱类型（var），动态型语言（识别当前的数据到底是
  什么类型）。
18.系统具有不同的版本，同一个程序，在不同的系统的中不一定可以跨平台，但是js是可以跨平台的
  ios开发，anduod，设计，后台，都可以使用交互，特效，开发。
19.  布莱登.艾奇，十天的时间，设计出来的，ECMAScript，宣传时间，借用的java的名头，导致现在依旧在
宣传，没关系。
20. js最初的目的就是解决浏览器与服务器之间的交互，比如，密码的强弱检测。
21.  展示信息，美化页面，计算能力。可以的项目：游戏，小游戏，页面，网页版的简历特效，博客园老师也在。
22.  html极速3d立体式相册制作：网络教程上传、
23.  js：在页面中进行验证，计算。是脚本语言，cmd，vbscript，却别之处，边执行，边编译。
24.  IDE：集成开发软件。（sublim，webstorm，visual Studio）没有高亮显示，没有自动换行，是记事本写代码的坏处。
25.  js点出来的东西与点不出来的东西：智能提示的东西可能不可以使用，智能并不提示的可能可以使用
  动态的解析，值的是在运行的时候才可以识别的语言类型是什么类型。
26.  js注意点：
  26.1变量具有大小写之分，var a=10；console（N）；
  26.2弱类型语言，定义变量，都是var
  26.3字符串使用单引号与双引号都可以，只有在与DOM一起使用的时候才可以使用单引号。
  26.4每一句代码结束后都要使用分号结束，不使用可能会出现不同的结果。
  26.5js中的注释：对代码的解释，相当于对文言文中的翻译。单行//多行/**/
27.  js代码script标签可以写在，但是要写body下最后面，好处是加载页面信息，最后加载js，速度快
  而且用户体验最好。就算放在html后，浏览器也要执行一次把js代码放在body中的工作。
28.  写法：
29.  数量：在页面中可以有多对js代码，第一行代码出错会影响当前的代码不会影响带后面的js代码。实例：
  引入：
30.  异步与同步：
  异步：多个人同时做多件事：js代码一边执行，一边下载，下载完毕，开始执行
  同步：一个人有顺序的做多件事。js代码中。上下显示，按照顺序。
31.异步的两种用法：async：页面开始加载，开始下载。下载好就开始执行。defer就是页面加载完之后
  开始下载，下载完毕后开始执行。
32.js的type：第一：在xhtml中要使用text/javascript，第二：h5中不需要写text，第三：language属性
  是在外部广告。
33.交换两个变量的值：1.第一种;第三方变量的方式，var mun1=10;var num2=20;var temp=num1;
  num1=num
  2，加减法：
  3:位运算，异或运算。*使用二进制10 1010 20 10100 30 11110 * var num=10; var num=20;(相同为1，不同为0) num1=num1^num2;（30
）num2=num1^num2;（10）num1=num1^num2;（20）console.log（num1,num2）;(交换结果)
34.  命名规范：1.英文数字下划线，$组成，开头不用$。2.驼峰命名法，第二个英语单词开始首字母大写
  3.初始化变量，使用多个赋值一次var声明就可以。
35.  判断名字或者范围使用boolean值，ture或false，1或0，真或假；
36.  undifined的情况：一种是声明变量但是没有进行赋值，另一种就是运算了返回值就是undifined。
37.  mul的情况：清空或者赋值。
38.  typeof（变量）显示变量的类型：num。str。flag。def。nul。obj；注意的是null的类型是object，null的值是null。
39.  两个类型的值在计算的时候是没有意义的：想要使用变量，最好先判断类型，是不是undifined或null
40.  蓝色是数值，黑色是字符换，经验而已不是标准。需要在控制台中判断值是否相等，使用单引号，双引号
  是不可的。第二种就是外边是双引号，里面就是单引号。
41.  NaN非数字，可以用来isNaN判断布尔值。
42.  var num=0xa; console.log(num1)(值为10)；这是控制台对所有进制的数值都会转换为10进制，
  在js中不可以进行别的进制的数据储蓄。
43.  js中的小bug，在存储小数的时候，小数有偏差，0.1+0.2+=0.30000004；不要测量像个小数的差与值。
44.  Number.MAX_Number()Number.MAX_Number
45.  字符串：特性内容不可变，只可以显示所有的字符串开辟的所有空间的内容。字符串中空格也算一个长度
  有些字在页面中会失效，那些事tab或者\\,只会显示一个\为的是跟上面的一行进行对齐。称为转义符。
46  \r\n\b
47.  加好用在两个字符串之间就是使用字符串链接的一起，两个字符串，就是拼接，一字符串一个数字
  就是字符串跟数字的拼接，数字型的字符串相加就不是拼接？（两个疑问，字符数字，与数值数字加减四种结果）
48.   布尔类型：两个值，false，true数字也可以转换，非0是true，0是false。字符串也可以，非空是true，空
  是false。3.undifined，null都是false。创建一个空的对象没有赋值，类型转换为true，但是给他赋值null
  就成了false。
49.  当一个变量没有赋值，undifined，当一个变量声明了没有初始化，也就是一个意思。返回值undifined。
50.  变量没有赋值，结果就是undifined，在if语句中就会执行else中的语句。
51.  数据类型转换：需要这种类型的值，就需要转换，1.其他类型转数字类型，其他类型转字符串类型，其他类型
  转布尔类型。
  51.1 Number（不管是哪个转换失败就是NaN） parseInt（只要开头的数字，字母开头就NaN） parseFloat（）--最常用的，严谨。
  51.2 parseFloat（0234）返回值就是234，转换的是全部的值，包括小数部分的值。小bug，前面的0会丢掉。8进制？
  51.3Number（）最常用，最严谨，parseInt()少用，比如银行的小数你给丢了，呵呵哒，完了。。。parseFloat不严谨，NaN。
52.  其他类型转换为字符串：数字可以，toString（10）ok。。String（undifined、null）ok！！
53.  字符串的拼接：两个拼接+、十来个字符串拼接的方法？？？？先把一串汉字输好，在那个地方添加变量，就
  在这里一对引号，加+。ok
54.  算数运算符，复合运算符，比较运算符，逻辑运算符。
55.  算数运算表达式：首先是一个表达式，有运算符链接起来的表达式。
56.  一元运算符：++  --  num++ num-- ++num  --num（特点是只有一个操作数就可以进行运算）
57.  二元运算符：1+1
58.  三元运算符：？ ：---》就是if》《=······
59.  复合运算符，复合运算表达式。内容：+= -= *= 
60.  比较运算符，比较运算表达式。内容：> < >= <= == === != !==
61.  逻辑运算符，逻辑运算表达式--。内容：&& || ！  里面一般掺杂着比较运算表达式
62.  a++与++a在遇到下一个运算符的时候必须要显示计算后的值。（重点理解四个计算结果）
63.  ture&&obj=obj···1&&2=2；同理为前面的理论。
63.1 优先级从高到低：（）优先级最高>>>元运算符++>-->!>>>算数运算符>>>*/%+->>>关系运算 > >>= > < > <= >>>相等运算
  == != === !==>>> 逻辑运算符：先 && > ||;
64.  流程控制：控制代码执行的顺序--顺序结构，分值结构，循环结构
  顺序结构：代码从上到下，从左到右（赋值=是特例从右到左）执行，
  分值结构：if语句，if-slse语句，if-else··if-els···语句，switch-case，三元表达式；
  if语句：if（表达式）{·代码段·}先判断表达式结果是true还是false，如果是true就执行里面的代码段，否则不执行大括号的
  代码段，直接执行大括号后面的内容。一般使用if语句就可以了，不需要if else语句的时候就不要这样使用。
  if-else语句：语法：if（表达式）{代码1}else{代码2}；判断表达式的返回值是true，执行代码1，false执行带吗
  这就是三元表达式：表达式1（或者值）？表达式2（值）：表达式3（值）；最多三个--
  var max=num1>num2?(num2>num3?10:8):(num1>num3?90:88);(这是三对)
  var if(num1>num2){if(unm2>num3){10}else{8}} elseif(num1>num3){90}else{88}}；三元的if-else
  if三种语句的使用范围情况分别是：一个树枝if，两个树枝if-slse，很多树枝，if-else if--ok！
65.  switch-case：语法结构：switch（表达式）{ case 值1：代码1；break； 
							   case 值1：代码1；break；}
66.  有new就是创建一个对象，案例根据日期判断惊天是星期几？
  var dt=new Date().getDay(){case 1:console.log(1);break;  case 1:console.log(1);break;  case 1:console.log(1);break;
  case 1:console.log(1);break; }
67.  当case中间具有多个case符合值的情况，只执行第一个case，只有当符合第一个但是第一个没有加break的时候，才会继续执行下面的case，这就是案例月份。
68.  给定一个变量判断变量属于哪个范围--
  var dengji="x"; switch(dengji){case "a":console.log("0-30");break;  case "a":console.log("30-60");break;
  case "a":console.log("60-90");break;  case "a":console.log("60-100");break; defout:console.log("no-search");break; }
69.  循环结构：同一行代码不停地执行，执行多次，包括;while循环。。do-while循环。。for循环。。for-in循环
  理解层面：开枪i=0;段哥跑步i++;，小杨计数i<=20;,语法结构：i=0；while（i<=10）{代码}
  理论：先判断表达式是否成立，成立的话，就开始执行内部代码，否则直接跳过循环。
  成立的情况执行内代码的i++----案例：使用while语句计算1-100之间所有数，所有奇数，所有偶数的和
  var i=1, sum=0; while(i<=100){if(!i%2=0){sum+=i; }i++; }
  再看一个死循环的案例就是不使用范围圈定。//提示用户输入一个账号与密码，账号是admin，密码是123，否则提示重新输入
  var userName=prompr("请输入您的账号")，userPwd=("请输入您的密码")；while(userName="admin"||userPwd="123"){
  您的密码或账号错误 } console.log（"登陆成功"）；
70.  //while-if-bresk语句可以用来寻找第一个条件的值
  var i=1; while(i<=200){ if(i%7==0){ console.log("i") } }
71.  //while-if-continue语句可以用来寻找所有条件的值的和
    
72.  while循环的特点是先判断后执行，有可能就是一次都不执行循环，do-while是先执行一次代码
  //使用d0-while来实现用户的密码与账号登陆与直接使用while循环的区别在哪里？
  var userName=""，userPwd""；
  do{ var userName=prompr("请输入您的账号")，userPwd=("请输入您的密码")； } while(userName!="admin
"||)
73.  三种变量的交换，三遍=======if中计算年龄的案例=======判断年龄的，判断成绩分数段if-else
  根据当前的时间显示星期，根据级别显示分数，===输入数字显示几位数===计算100以内所有，偶数，奇数，
  所有能被7整除的数==break跟cotinue做一次值与所有值的案例===只要不输入y就一直问我：我帅不帅
  ===账号和密码的判断：while与do-while。
74.  null是一个object类型
=======================================================================
js第二天
1.js代码与其他代码混合在一起，就是单引号好。
2.js写法，内嵌式，内联式，外链式。不要在外引入的js文件的script标签中写代码。
3.逻辑运算符中的表达式true与false的返回值，是短路原则。只有赋值是从右到左。
4.只要其中之一，if就够了，要有两个结果就是if-slse或者三元表达式，多对区间if-else-if。对于多个值，取多个区间，就是用switch。
5.在输入的数字的前面需要使用Number，或者parseInt来转换字符类型。
6.while语句与if语句的嵌套可以相互交叉--案例：求位数
var num="";

7.for循环：必须添加的几个语句，i++否则陷入死循环，声明一个i=""，否则进不去循环的条件。运行原理：（var i=0;i<=length;i++;）{ 循环体 }。
小案例：输出哈哈我又变帅了
for(var i=0;i<=10;i++;){
	console.log("我又变帅了")
}
三个表达式是可以省略的，省略就是死循环。
//求1-100之间所有数字的和
//定义变量，存储数字的和
var sum=0;
//循环求和
for(i=0;i<=100;i++;){
	sum+=i;
}
console.log(sum);
//控制台输出结果
------------------------------------
//求1-100之间的所有的奇数的和
//定义变量，存储数字的和
var addSum=0;//存储奇数的和
var evenSum=0;//存储偶数的和
for(i=0;i<=100;i++;){//添加if-else语句
	if(i%2!=0){//这是奇数的语句
	addSum=addSum+i;
}else{//这是偶数的语句

	evenSum+=i;
}
}
console.log(addSum,evenSum);
----------------------------------
//已知本金和利率，求5年后的本金与利息，使用0.003不要千分之三，本金10000元存入银行，利率是千分之三，每过一年本金加利息，再进行计算，计算5年后的本金加利息//
var money=10000;
var rate=0.003;
for(var i=1;i<5;i++){
	money=money+money*rate;//下一年的本金
	money+=money*rate;//money=money+money*rate,
}
console.log(money);
----------------------------------
//斐波那契数列：黄金分割数列，可以计算兔子的繁殖数量,期初有两只兔子，
var num1=1;
var num2=1;
sum=0;
for(var i=3;i<=12;i++){
	sum=num1+num2;
	num1=num2;
	num2=sum;
}
console.log(sum);
----------------------------------
//一到五之间所有数字的和断点调试
var sum=0;
for(var i=0;i<=5;i++){
	sum+=i;
}
console.log(sum);
-------------------------------------
//打印九九乘法表
document.write("<table border='1'>")
        for(var i=0;i<=9;i++){
            document.write("<tr>")
            for(var j=0;j<=i;j++){
                document.write("<td>")
                document.write(j+"X"+i+"="+j*i);
//                document.write("<br />");
                document.write("</td>");
            }
            document.write("</tr>");

        }
document.write("</table>");
--------------------------------------
8.数组的作用：可以一次性存储多个数据
数组的元素：存储的每个数据。
如何获取数组的元素的值？
如何设置数组的元素的值？
--通过索引（下标 的方式来设置数组的元素的值）
数组如何定义？
三种方式:
var 变量=[ ];字面量的方式定义数组
var 变量=new Array();构建函数的方式设置数组
注意：js中数组是可以设置长度的
	数组中每个元素都是以逗号隔开的。
	数组名.indexOf(值)，判断匹配量，没有就是-1.
原理：栈与堆：让时间倒退，使障碍物消失，现场再次恢复时间，恢复现场。
	栈--有序的上下存储空间（入栈从下到上，出栈，上到下，加一次值，开一次空间）--编号（有序的集合，从下到上，0-oo）
	堆--无序的杂乱空间--
数组是存储在栈空间的，取值叫获取--赋值叫设置；
获取----
var num=[10,20,30,40]
var result=num[2];
console.log(num);==30==
设置----
var num=[10,20,30,40];
var[4]=[50];
console.log(num)//num=[10,20,30,50]
数组的长度是可变的
var arr=[1,2,3,4,5,6,7]
arr[7]=8;
arr.length=8
空数组后面的数值是长度（），但不是空数组，已经开辟了空间
var arr=newArray(3)--表示数组的长度是3
var arr=newArray(3,5)--表示数组的元素是[3,5]
索引（下标）==个数-1；-------注意下标的最大值是length的值-1
var arr=new Array(num);//长度是num
var arr=new Array(num，num2);//这是数组的两个值***
数组可以一次性储存多个同类型或者不同类型的数据
var arr=[1，undifined，null，"hellow",1233];
//提示输入人数，根据认识求班级每个人的成绩，再求所有人的成绩和，与平均数
for(var i=0)
 
//1.求数组中的和，平均值，最大值，最小值
//数组的最大最小值，总数，平均值
var arr = [20, 90, 76, 44, 77];
var sum = 0;//
var avg = 0;//
var max = Number.MIN_VALUE;
var nim = Number.MAX_VALUE;
for (var i = 0; i < arr.length; i++) {
    sum += arr[i];
    avg = sum / (arr.length);
    if (max < arr[i]) {
        max = arr[i];
    }
    if (nim > arr[i]) {
        nim = arr[i];
    }
}
console.log("最大值是：" + max + "最小值是：" + nim + "和是：" + sum + "平均数是：" + avg);
----------------------------------------------------------------------------------------
//2.将数组的每个字符串元素用”|”竖线的方式隔开，并输出
var str=[];
var srr=["ever","ever","ever","ever","ever"];
for(var i=0,i<srr.length;)

//3.去掉数组中的0，产生新数组。
        //4.实现反转数组
        //5.根据输入班级人数依次输入每个人成绩,求总成绩和平均值
        //6.随即生成10个1-100内的非重复数字放入数组中。(调用系统方法)
        //7.求一个工资数组中，员工的最高工资、最低工资、平均工资
        //8两个数组{ “a”,“b”,“c”,“d”,“e”}和{ “d”, “e”, “f”, “g”, “h” }，把这两个数组去除重复项合并成一个。
写一行代码求班级的人数与班级的平数---------------------
        var pers=parseInt(prompt("请您输入班级人数"));
        var scores=[];//
        var sum=0;
        for(var i=0;i<pers;i++){
            scores[scores.length]=parseInt(prompt("请输入第"+(i+1)+"个同学的成绩"));
            sum+=scores[i];
        }
        for(var i=0;i<scores.length;i++){
            console.log("第"+(i+1)+"个人的成绩是"+scores[i]);
        }
        console.log("总成绩是"+sum+"分，平均成绩是："+sum/pers+"分");
--------------------------------------------------------------------

9.函数：把需要使用的代码段，封装在一个变量中，需要的时候直接调用就可以。
作用：可以重复使用
定义：dunction 函数名（）{
		函数体；
	}
	//调用
	函数名（）；
切记：目前函数首字母不允许大写。
10.while循环的特点：不知道循环次数，i++必须要用
   	for循环知道循环次数
	do，while循环，先执行一次
11.arr[arr.lnength-1]----->数组的最后一个元素值。

3.16-----------------------------------------------------------------
1.函数的参数和返回值。。函数的形式。。。注意事项。。。。案例。。。两种定义（匿名）。。。回调函数。。。js没有块级作用域。。。预解析。。。
2.函数中的参数和返回值
	函数是指封装一坨代码，使用的时候来调用，作用是可以重用。相当于装在一个盒子里却没有打开，打开的过程就是调用。函数的每一个功能尽可能的单一。
	函数的参数：函数在定义的时候后面的小括号中的变量就是参数。参数的个数根据需求设置，一般是要求求值的变量数。记住，函数参数（变量）命名时不需要var。函数的参数需要值，如果传参给的是undifined，函数的计算结果是nan。正确的使用时，形参与实参与外部var是一一递交的。传参：实参的值传给形参；console.log（函数名）--》显示函数；在js中函数的形参个数与实参的个数可以不一致，其他的语言中必须一致。
	返回值：在函数内部如果有return，下面的不再执行，返回函数的结果。
3.函数的两种定义方式：
函数声明function 函数名（）{}--命名函数存在冲突问题
匿名函数的赋值function （）{}使用匿名函数，赋值给一个变量var f1=function（）{}；（后期常用）
4.（function（）{console.log（“xxxx”）；}）（）；函数的自调用，一次性；
5.函数的回调，函数既可以作为参数传参给形参，也可以作为返回值，既return。
6.当一个变量声明了没有赋值，或者函数申明了没有明确的返回值，都是undifined
6.1声明了变量，但是没有赋值；	
var num;
console.log();-->undifined
6.2定义了函数却没传参
var num;
console.log();
function getDay(num1,num2){
    return num1+num2;
}
console.log(getDay())-->NaN
之前学过的一个小案例，因为在js中采用的是二进制浮点数的编程，所以0.3-0.2！=0.2-0.1，因此，js中不要计算精确小数的加减法
判断一个参数或者变量值是不是NaN，type（x！=x）当结果为true，表示结果正确
6.3定义并且传参，但是函数内没有明确的return，相当于没有计算出结果，输出的是undifined
var num;
console.log();
function getDay(num1,num2){
    return ;
}
console.log(getDay(3,4));-->undifined
7.看几种控制台输出方式的等效替换。
function f1(x,y){
        var sum=x*y;
        return sum;
}
var result=f1(12,3);
console.log(result);
console.log(result)=console.log(f1(13,3))
8.看几种控制台return方式的等效替换。
function f1(x,y){
        var sum=x*y;
        return sum;
}
var result=f1(12,3);
console.log(result);
//--------------------------------------
        var sum=x*y;
        return sum;
上式等效于return x*y；
9.如何区分对象属性中的方法与函数的区别？
有点的是方法，没点的还有代码段的就是函数
10.函数的重名问题？
	对于自己定义函数名的情况，函数可能会执行所有的函数，但是最后的返回值，或者显示的代码只是最后一个重名函数的效果；对于系统的函数发生重命名的冲突，就会导致系统的函数被覆盖。
11.案例
求数组中的最大值,最小值,求和
-----------------------------
function getNumberAll(arr){
    var min=arr[0];
    var max=arr[0];
    var sum=0;
    for(var i=0;i<arr.length;i++){
        if(min>arr[i]){
            min=arr[i];
        }
        if(max<arr[i]){
            max=arr[i];
        }
        sum+=arr[i];
    }
    var minMaxSum=[min,max,sum];
    return minMaxSum;
}
var arr2=[1,2,3,4,100];
getNumberAll(arr2);
console.log("最大值是："+getNumberAll(arr2)[1]+"最小值是："+getNumberAll(arr2)[0]+"和是："+getNumberAll(arr2)[2]);
------------------------------------
求3个数字中的最大值
--------------------------
function maxNumber(a,b,c){
    return a>b?a:b>c?b:c;
}
console.log(maxNumber(3,8,9));-->9
----------------------------------
.反转数组
--------------------------
function reNum(arry){
    var arr2=[];
    for(var i=0;i<arry.length/2;i++){
        arr2[i]=arry[arry.length-1-i];
    }
    return arr2;
}
var arr1=[1,2,3,4,5];
arr1=
console.log(reNum(arr1));-->[5,4,3,2,1]
----------------------------------------
数组排序
----------------------------------------
function maoPao(a){
    for(var i=0;i< a.length-1;i++){
        for(var j=0;j< a.length;j++){
            if(a[j]>a[j+1]){
                var box=a[j];
                a[j]=a[j+1];
                a[j+1]=box;
            }
        }
    }
    return a;
}
var arr1=[3,7,6,4,9,1,0];
console.log(maoPao(arr1));-->[0,1,3,4,6,7,9]
------------------------------------------
求一个数字是否是质数
---------------------------
function isPrime(num){
    for(var i=2;i<num;i++){
        if(num%i==0){
            return false;
        }
    }
    return true;
}
var flag=isPrime(89);//返回的值是布尔值
if(flag){
    console.log("这是一个质数");//条件为true
}else{
    console.log("这不是一个质数");//条件为false
}
--------------------------------------
先知道一个定义。
作用域：变量（对象的使用范围）
局部作用域：在函数内部使用，外部无法访问；
全局变量：声明的变量在整个页面，包括内部的函数都可以访问这个变量，举个栗子，if-else；while，for；var，都可以被访问，这就是全局变量的特点。
在js中有没有其他语言中的块级作用域？
正确的答案是没有，只有一只类似于块级作用域的现象，这种现象就是函数，在函数中定义或者声明的变量，在外部页面中，或者外一级的函数中，是没有办法的到声明的函数的。
另一个定义。=
函数的回调，在函数传参的过程中，可以使传参一个数值，也可以四一个函数，但是，到底可不可以传参给自己呢？答案是可以。但是会陷入一个死循环中。
3.19===========================================================
1.大量数据想要进行历遍，就要使用实现树状结构的递归。
2.字符串的特性具有不可变性，她的特性是储存在地址中，也有数组特性，可以获得，但是不可以通过数组的形式进行设置。
3.特性：封装继承多态（抽象性），基于对象的语言，不是面向对象，也不是面向方法。
4.自定义构造函数，就是一种自定义数据类型，这是它的模拟性
5.newObject();---function xxx(){};var obj={};
6.for-in-遍历对象中的属性名，xx是属性名obj【xx】是属性值；
7.js的基本数据类型，与复杂数据类型？
分类标准：
js的原始数据类型：number，string，boolean，undifined，null，object
基本类型（简单类型）：number，string，boolean，undifined
基本的数据类型都是储存在栈中的，就业称为值类型
复杂类型：object，数组，函数，Date（null即可以是复杂，也可以是空类型）
复杂类型的的对象是存储在堆空间中，但是地址在栈中，没办法直接修改栈中的属性，设置值的话，智能通过开辟新的空间。又叫做引用类型。引用繁荣解释，在堆中存储，字栈中引用。
基本包装类型：Number，Srting，Boolean，
空类型：null，typeof属性是object
什么时候使用null，当变量对象要清空空间的时候，一般用在局部变量的重新初始化。
7.1理解在栈与堆的环境中，各种数据类型在其中的存储原理：
var num=10，flag=true，str=“小白菜”；所有的语言中字符串是最难的，在js中，在不同的情况下，字符串string会不等的转化数据类型：直接定义一个字符串var这是一种值类型；
在栈中的数据储存方式，使用机器语言的顺序，开辟空间--存储数值--复制并粘贴--设置是替换，传递的是值；
在堆中的存储方式，
function Student(age,sex){
	this.age=age;
	this.sex=sex;
}
var stu1=new Student
var stu2=stu1;
stu2.age=100;
console.log(stu1.age);
//给的只能是地址，指向同一块空间，即两个地址公用一块空间，访问的this.属性是一样的，什么情况下是不变的？


8.基本包装类型对象--基本包装类型的变量与基本包装对象
变量在调用属性或者方法的时候，此时的变量就是对象，装的变量就是基本白装类型。这个变量就是是基本包装了类型的对象。
明确的两个规则：变量不能直接调用属性或者方法；对象可以直接调用
基本包装类型：Number，Srting，Boolean！！！
varstr=“哈哈”；----基本类型
var str=“哈哈”==var str=new String（“”）；
conso.log（str.length）----调用了属性变成了基本包装类型
var str=new Object{“哈哈”}；------变成了复杂类型也就是对象类型
9.它们不是函数，知识统统的内置对象
Math.xx----
9.2 Date.xxx---可以使使用new Date（“字符串”）；是一个特殊的用法；转换失败就是NaN或者invilatal Date；
var result=Date.now（）/当前时间的毫秒数
Date.parse("2017-4-19")；
var dt=new Date();
console.log(dt.toLocaleDateString());//标准的时间
console.log(dt.toLocaleTimeString());//时分秒
console.log(dt.getMonth+1());
console.log(dt.getDate());
console.log(dt.getHour());
console.log(dt.getMinites());
console.log(dt.getSeconeds());
//----------------------------------
function getDate(dt){-----封装一个函数求它的标准时间包括年月日时分秒
	var str="";---------声明一个变量是字符串，类型是字符串不赋值
	var year=dt.getFullYear();-获取年份的数字
	var month=dt.getMonth()+1;-
	var day=dt.getDate();
	var hour=dt.getHour();
	var min=dt.Minutes();
	var sec=dt.Sceconeds();
	month=month<10?"1"+month:month;--三元操作符
	day=day<10?"1"+day:day;
	hour=hour<10?"1"+hour:hour;
	min=min<10?"1"+min:min;
	sec=sec<10?"1"+sec:sec;
	str="year+"年"+month+"月"+day+"日"+hour+":"+min+":"+sec";
	return str;
}
	var dt=new Date();
	var str=getDate(dt);
	console.log(str);
//------------------------------------
当出现报错为：某个变量是undifine of ，即需要形参计算，没有实参传入
str.fangFa();-------str.shuXing;
	
String.xx---
字符串的变量都可以使用字符串代替，后面直接加点号就可以了
.trim()方法，无参数，有返回值（字符串类型），干掉字符串凉拌的空格，正则表达式去掉中间的空格
**.concat()方法，有多个参数，可以把多个字符串拼接为一个字符串。
**.charAt()方法，参数是数值类型，可以把一个字符串的当前位置的索引返回为一个字符串。
.charcofeAt()方法，求出某个位置的ASCLL编码。
.slice(1,5)方法，第一个是开始的索引，第二个是结束前一个的索引。ellw
.substring(3,4),第一个是开始，第二个是结束（可以一个值，默认第二个是到结尾）
**.substr(3,2),第一个是哪一个索引开始，第二个是长度length。（可以取消一个值，默认是到结尾）
**.indexOf("你",6);找你，从6的索引开始找，找到显示索引，找不到就显示-1；
.lastindexOf("o");规则是从后往前找，找到字符，从前开始计数。
.replace（"aaa","bbb"）aaa要替换的字符串,bbb是替换后的字符串。
.toLocaleUpperCase()转大写
.toLocalelowerCase()转小写
.search（"正则表达式"）相当于indexOf但是找的是正则，有就是索引号，没有就是-1；
.replace跟.toLocaleupperCase都可以改变字符串的字母知识看起来这样而已，实际的原来的字符串还是不变，知识返回了一个新的字符串，原理就是替换，不同于数组，直接可以使用arr[i]的方式就可以设置某个值。
var str ="我发现那个美女真的很美";
var index=0;
if((index=str.indexOf("美女"))!=-1){//查询具有美女二字的索引数字赋值给index
	str=str.substr(index);//以index的值为新字符的开始一直到结束
}
Array.xx----常用的几个数组的方法
-arr.pop();
-arr.push("what")
-arr.unshift("why")
-arr.shift();
-arr.length;
-arr.split("-")去掉该符号，使用逗号隔开，成为一个新的数组。
-arr.filter-var一个新数组，赋值是函数return，返回新数组
使用agument.length可以检测有所少个参数。agument（元素）
NaN是一个数值简单数据类型，含义是非数字，null是一个object，是一个无值的对象。
3.21Dom=================================================================
1.DOM，Doncument object model 文档对象模型
页面中的所有内容都是对象，包括所有的文字，标签，属性，就是说，DOM就是页面中大对象中有很多小对象，树形结构。
1.1xml文件是用来存储信息的，而且xml的好处是不会跟随软件的消失消失，可以在电脑中直接打开
2.js的作用最初的目的就是验证密码，后来加入了js对页面html中元素的操作，就是---DOM。
3.页面中的顶级对象是document，不是浏览器中的顶级对象，标签可以叫做节点（node==标签==元素），文档元素：根元素是html，其中的三种节点：父节点，子节点，兄弟节点。
4.小的经验，有限元素不需要就可以隐藏。
5，最好的使用方法就是把js代码放在一个函数中，在HTML中使用函数的调用，在使用函数的调用的时候，就要在标签中添加一个触发器的功能属性，onclick，内容就是“”下得字符串，"f1();"这样的形式，这是内嵌式的写法。还有一种是使用id，或者class的方法，这样的话，标签要写在前面，js代码写在后面，否则会报错，null，其实是没有错误的，这样的话，触发器的情况及时，不可以使用（），必须要使用f1，否则就不是调用函数，二回返回值。
6.点谁谁怀孕的功能用到的是排他的作用。只要是当前就用this。
7.固定的写法，不让超链接跳转，return false！！！阻止默认的跳转，一个标准的hrml标签，
8.不要依赖代码的ide的智能提示，智能提示最好是在写代码的过程中单词的遗忘
9.value的意识是给服务器看的，用来定位这个按钮的位置。
10.使用value跟inner跟value都可以改变文本中的默认选项，但是使用value是不可以改变f12中的element的属性。真正的改变就要使用innerText=“”；
11.学会使用id选择器与类选择器，id用来注册按钮触发，类用来相应要求的属性效果，标签选择器要有for循环进行一个数组模式的遍历，最后，通用的js代码要写在一个独立的文件中，使用的时候直接使用就好，通用的调用节点，或是标签，或是元素的部分属性，封住一个函数名为my$(){},进行累的调换的时候，触发器中的函数，一般要先得到一个名字下的所有元素，其次进行for循环的时候，要设置的lengeth是包含这些遍历的标签，调整属性的时候，如果zaijs中写一个属性名里面有好几个属性值，中间使用空格隔开。
12.事件源--触发--响应:获得事件源的属性对象，设置触发的onclick，或者onmouseover的函数；函数内包含的就是响应需求的对象中的属性中的属性的值的设置！！！！
13.获取的方法（API）getElement(s)By+Id/TagName/className
14.为元素添加事件的方法：本身拥有什么属性，就有什么方法。
15.如何理解this这个方法--当前，自己查询权威指南
16.为什么说浏览器在发送请求与返回的都是字符串？
客户端发送请求，通过网络云，到达服务器，服务器找到要请求的那个文件，返回请求的文件，是一个dom，就是字符串，修改DOM时，修改的是客户端，不是服务器端。
17.js是在浏览器端执行的脚本语言弱类型，脚本语言，动态性型，
脚本语言：不需要编译，直接运行，边解析边执行的语言。
动态语言：在运行是确定数据类型。
弱类型：声明变量都用的是var，不同于其他的语言。（js对于学习java与c#有很大的帮助）。
还有一个补充的--抽象性：指的是它的语言并不是其他语言那样规范，比如string的数据类型的不同场合的情况是不一样的。在var直接声明的赋值中就是字符串类型，在引用他的length的方法时，就是对象。
18.在DOM中一定要注意使用注释，合理的注释是帮助自己也是合作的前提，没有注释，在别人看来，你的代码就是一团乱线头，降低了开发的效率，那么，注释应该怎么用呢？
首先，注释用于解释某些复杂的代码的逻辑，这种情况，就需要在一行代码的上部分与代码所在的一行上说明代码的返回值或者计算方法，上面写的是要实现的功能，这样就方便后期的维护与开发。
再次，注释对整个模块进行划分，比如最常用的呈上起下，分割线。
最后，每一块模块实现的功能，封装的匿名函数，命名函数，复杂的逻辑（比如函数的回调计算斐波那契数列，计算位数的和），从外部引入的文件，维护的记录这些地方都要进行注释，就是一种规范。
19，就语法角度来讲，分号的作用，从原理的角度来讲，浏览器可以自动补全一句没有分号的语句，这样，对于一些不会报错的情况来讲，就会产生错误的结果，比如各个字母的加减，自加自减，都会应为不自己加分号，产生不报错的错误。分号在所有的=后面必须加，只要用到了赋值，这句话必须加分号。
20.css与js的引用说法不同？
同样是写在html结构中，css交内嵌式，js交内联引用；同样是写在当前结构中的head中，css叫内链式，js叫内部引用；同样是使用外部文件，css叫外链式，属性是href=“xxx.css”，js叫做外部引用，属性是src=“xxx.js”。
除了使用id获得的方式，其他的documents通过获得的方式得到的是一个数组，需要遍历！！！
21.如何区分f1();与f1;的区别？
3.22DOM=====================================================================
1.获取元素的四种方式
document.getElementsBy/Id(),TagName,Name,ClassName;
2.添加事件的三种方式
第一种：
<input type="button" value="按钮" onclick="f1();">
function f1(){
	alert("第一种写法")；
}
第二种：
<input type="button" value="按钮" id="btn1">
function f2(){
	alert("第一种写法")；
}
document.getElementById("btn1").onclick=f2;//这是命名函数--直接获取直接注册点击事件。
第三种：
<input type="button" value="按钮" id="btn2">
document.getElementById("btn1").onclick=function(){

};//这种方式是获取点击事件直接在后面加上处理事件。
3.innerText获取的是标签中的纯文本，innerHTML设置的是获取标签的标签加文字内容包括了标签的样式也一并修改。还有一个textContent，跟innertext效果一致，在这里涉及到一个问题就是兼容性，这个是后期前端需要重点掌握的内容，
4.难点也是需要掌握的是就是动态的遍历数组，并且操作这个数组里面对象的属性。
5.如何为元素动态地添加属性？
使用setAttribute("属性的名字",num(num+=i)就是值),使用getsetAttribute("属性的名字"）可以得到该属性下面的值。
5.1小案例：移出html中的属性与属性对应的值，三种方式
html········
my$("dv").className="";
my$("dv").setAttribute("属性名","");
my$("dv").removeAttribute("属性名");这个去除的最干净。

6.鼠标位置对应的几个属性：
激活：onfcous
3.24=============================================================================
节点：
nodeType节点的类型
1----标签
2----属性
3----文本
nodeName节点的名字
标签----属性名字大写
属性----属性的名字原名
文本----#text！！！
nodeValu节点的值
标签----null
属性----对应的值
文本----文字
2.节点与元素的相互对应，元素是标签开始计数，节点是从空白区域就开始计数。
my$("uu").parentNode----parentElement---ie8,火狐，谷歌都支持
mt$("uu").childNode----child--ie8获得的都是元素，火狐与谷歌获得的是两种，ie8只有元素
my$("uu").firstchild--firefox and chrome获取第一个子节点、ie8获得第一个子元素
my$("uu").firstElementchild---谷歌火狐是第一个子元素、IE8不支持。
获得节点的方式与获得元素的方式中，谷歌与火狐支持的两种是一样的，兼容性出现在IE8中，节点全部过滤没有文字的空白节点自动转化为元素，如果空白节点拥有文本，那么就会显示文本的内容，除此之外，一致显示的都是元素。谷歌与火狐都支持元素的获得方式，IE8是不支持所有的元素的获得方式的，console的结果都是undefined。
3.
.parentNode---parentElement父级的节点与元素
.childNodes------children子级的节点与元素
.firstChild------firstElementChild第一个子节点与子元素
.lastChild-------lastElementChild最后一个子节点与子元素
.previousSibling--previousElementSibling上一个兄弟节点与元素
.nextSibling-----nextElementSibling下一个兄弟节点与元素
4.节点与元素的区别：元素显示标签与标签内的内容，节点是指的是所有相邻的内容，包括了空白。
5.兼容性代码，一方面检测了浏览器是不是可以支持要求的内容，很多时候，就是需要什么就给什么，需要的做的最好，其他的需求不要随便取更改与添加，画蛇添足是一件不好的事情。
6.JavaScript：void(0);表示这个链接是不跳转的。
7.为什么要动态创建元素？当用户需要的时候下载页面，为了体验
7.1document.write();
7.2innerText
7.3document.createElemnt("div")
8.在script标签中设置type与language；这是调用百度额免费新闻，给的是一个链接，可以同步的修改自己页面借用的新闻页面。我的的页面只需要设置一个放置的位置，该新闻的内容是百度的服务器里面机型修改，最后的页面是百度的document.write();给的我们。但是直接使用document会把所有的页面内容都抵消掉。
9.全角的文字与半角的文字在页面中出来的样式不一样，有空格
10.对象名.name==对象名["name"];
11.使用字符串的拼接，在单标签的最后需要加一个空格，否则就会出现拼接结果出现/
12.使用数组转化为字符串的时候，需要str.join("");
13.一个兼容性代码，使用innerText与textContent
function setInnerText(element,text){
	if(tyoeof(element.textContent=='undefined')){
		element.innerText=text;	
	}else{
		element.textContent=text;
		}
}
//其次获得任意元素中的文本，因为识别问题，需要使用两种方式
function getInnerText(element,text){
	if(typeof(element.textContent=='undefined')){
		element.innerText=text;
	}else{
		return element.textContent=text;
	}
}
//对于上面的两个函数，如果要获得处理结果就是得到最后的结果输出，就需要设置return，但是如果不需要结果，只要给函数中设置值，就不要return；
14.第二个兼容性代码--使用元素与节点的获取，IE8只可以使用节点获取方式来获取元素，其他的谷歌，火狐浏览器直接使用获取元素的方式
function getFirstElement(element){
	if(element.firstElementChild){
		rerurn element.firstElementChild;
	}else{
	var node=element.firstChild;
	while(node&&node.nodeType!=1){
		node=node.nextSibling;
	}
		return node;
	}
}//-------------------------------------
function getLastElement(element){
	if(element.lastElementChild){
		rerurn element.lastElementChild;
	}else{
		var node=element.lastChild;
		while(node.nodeType!=1){
			node=node.previousSibling;
		}
	return node;
	}
}//---------------------------------------
3.25DOM04=====================================================================
复习：设置对象的属性的两个方式一个是对象.属性.值----另一个是对象.className="";
document.write()页面加载完毕之后会把页面中的所有的内容全部干掉
对象.innerHTML="html代码";实现这个行为是保存在处理函数中的。
1.使用js去实现页面中的所有的获得的特效，难处在于循环中的this的使用。尤其是列表的滑动特效，这是重点，也是难点，常见的使用for循环进行的有，列表的行的颜色的切换，还有tab的滑动，实现的原理就是：首先获得要遍历的一系列的对象，在for循环中对选取的对象数组进行遍历，也就是在循环中一一设置它的style属性并对应一个新的函数，在函数外，创建一个命名函数，命名函数中，使用的就是样式的值的变化与各种赋值。
2.在字符串拼接时，一般最外层是双引号，内层的引号的特点是：字符串的类型，使用单引号，使用变量，使用"+num+";
3.this在哪
4.在页面中创建表格要使用tbody的模式，在IE7中是不可以识别不是tbody格式的表格的；
5.祝福墙最终版的设计理念：
打开是一个空的墙，先根据在js文件中保存的数组，先把每个便签最外边的div，设置样式，位置，设置id，把这个div防盗最外面的div中，每个便签除了最外面的div外，其他的的标签的和内容都是用字符串的拼接。
线循环遍历数组，创建div标签，加入到id为count的div中，设置id，类样式
再创建一个对象包括了数组中的所有的对象；
创建一个对象，使用createElement（“div”）的方式，接下来一修改获得的对象的id，className，，这个时候就可以每次获得这个设置好样式的标签，使用父级对象.appendChild(对象名)；获得盒子，需要在盒子里面写入样式与内容，使用字符串拼接的的方式实现，得到一个变量对象，在最后使用innerText出输出str。
6.先获取文本框，添加键盘抬起事件，意思是，键盘按下不会触发，当键盘抬起才触发，比如连输一串数字，实现的模式是，首先定义一个数组包含的是所有要出现的字符串，其次获取注册处理，触发器是onkeyup，，接下来进项数组的遍历，寻找0号索引的字符串的值是否符合要求，符合要求的写法是indexof(dd)==0,执行空数组的赋值，依次从已有的数组中去除符合if的数组，接下来在大盒子中补上一个push，在这之前声明一个p标签，直接使用，并且进行样式的设置，这里因为判断的空格，无输入也会出现盒子，需要使用判断空数组与输入字符串value的length来删除多出来的盒子。
7.对象的方法一般都是增删改查
8.一次性获取多个元素，多个页面展示的标签，一种方式是获得循环前数组，在循环中使用字符串，最后赋值给innerText，另一种是，图库中有有规律的路径，使用有规律的数字变化，可以读取到
9.对于声明字符串写在for循环内与循环外的两个用法：
第一种：写在for循环内--要求每次都清空变量，且是一轮解析一次，字符串不累加，循环内使用innerHTML
第二种：写在循环内，要求循环结束后，得到所有的字符串的，再解析这一串字符，一次性得到全部的标签。
10.disabled/selected/checked=1/0，只能在js中对它进行赋值，在结构中只要有就是禁用文本框。
==========3.27DOM05=========================================================
1.Windows.Location.属性;---浏览器
1.1--hash--获得浏览器地址
1.2--host--获得文件地址与端口号--Localhost:63342;--肉鸡
1.3--hostName--
1.4--pathName--文件的相对路径
1.5--port------端口号
1.6--protocol--
1.7--search----
2.window.navigator.方法
2.1
3.在js中获取一个样式的属性值是数字的话，就是使用offsetLeft这样的属性。
在改变类样式的时候，使用for循环，
第一步，遍历【i】的removeAttribute（“类名”），
第二部，this。classname=“类名”；
4.使用off与对象点出来的属性数值型有啥区别？
off的使用，可以获取也只能获取，因为塔不可以被设置，不可以使用。dff=？？这样的形式，对于在结构中的宽高可以直接点出来style得到字符串，但是写在css中的数值只可以通过off获取，offset中有很多属性，我们最常用的就是宽高，上左四个，使用的方法就是，在js中使用的时候就是当前的数值xxx.offsetleft
5.永远记住只要上面脱标，下面就会顶上去，但是好像图片与文字不可以被覆盖？
6.在获取子级样式的边距属性值的时候，父级脱标不会计算父级的所有宽度，不脱标就是计算父级元素的边距。
7.获取元素，从大到小，最大的就是document.documentElement==Html;
8.this的使用原则，要用的属性是谁搞出来的，this就是谁？但是为什么不直接使用该值的原始属性，是因为一般this是用在循环中的，不适this就会值执行最后一个循环。
9.关于scroll与
10.一般情况下，我们需要使用封装多个函数，来返回我们需要的返回值，但是，使用一个新的方式，在封装的大函数中，把多个封装的函数的返回值需要在下面调用，可以使用键值对的方式，一次返回一个数组，数组中包括多个对象的键值对
11.实现层的运动需要封装函数，大的案例需要熟练
==========3.28DOM06==========================================================
1.清理定时器，定时器是指的在相同的间隔内，执行同一条函数，
2.在缓动动画中，使用的step中，整数需要向上取整，避免0.9是0；另一种是
3.前几天的bom做一个总结回顾，使用bom执行
4.Obj.age====Obj["age"];写完之后进行测试；如果点出来的属性与方法是变量就不适用“”；
5.传对象是forin，传数组是for,都是遍历的方式，在获得字符串的时候需要对字符串进行遍历，在循环中对每个数组对象进行属性的设置，或者方法的设置，搭配this使用，有很好的效果，反观定义的对象，对象采用键值对的方式，每一个对象的内部都是多个键值对，在使用的时候要注意使用的方法，在封装的过程中，使用到了符合每一个对象结束的方法。
=========3.30DOM07==============================================================
1.复习，在封装的直接执行计数器的缓动过程是这样实现的，首先是匀速动画函数，其次是缓动动画函数，再次是增加任意单一的属性，之后是添加多个属性同时执行，最后是添加了回调函数，完美版是添加了不同的计算方式的透明度与层级。---对应的是旋转木马
2.鼠标跟着图片飞，就是京东详情页面的放大镜的执行需要注意的是鼠标箭头跟图片的最中心不在一个位置，要考虑到是否是margin的影响，需要去减去或者加上margin的值。获取鼠标的位置与图片的position的位置一直，对于不一样的浏览器，需要写一个兼容对象，获取其中的page值。
3.window下的三大系列：offset，licent，scroll。
4.实现滚动条的高度：实现的比例原理是，滚动条的高度/滚动框的高度=可视区域的高度/文本内容的高度。
5.绑定事件的兼容性代码需要用到三个判断，事件的解除与事件的绑定的参数一致但是在函数的参数的方面以一些不同，解除需要函数在外面，两次都要调用传参。
6.this的定义：调用当前方法的对象。
7.事件的冒泡，事件的目标，事件的捕获，只要不清除，就只有两个阶段同时执行。清除的方法：stopPaga
3.31京东=====================================================================
1.从上到下，实现的需求--实现的样式原理与注意事项--实现用到的代码
1.1顶部通栏的按钮都可以使用点击后都可以使用ul的定位方式，以显示方式的隐藏与显示
1.2
1.3
1.4当鼠标进入北京，的最小的包括div显示为block
2.需要注意的地方：js写在最末尾，独立一个文件---div的功能分工明确，一个div一个功能，不要混用。
4.1京东2======================================================================
1.页面多做几遍尤其是频繁使用的地方要重点掌握。
2.排他功能，只选一个，for循环使用className清除掉样式，for循环之外使用this。
3.正则表达式：首先是一个表达式，有一定的规则，也叫做规则表达式，按照一定的规则来匹配字符串的表达式，例如，匹配字符串的“123344”，又有规则的符号组成表达式。
使用：
元字符：
.-------表示除了\n之外的任意的单个的字符\/\/\/\/\/\/\/\/\ui/io/y\/ty\/fb\/45\/\/\
[]------表示的是范围，[0-9]表示的是0-9之间的任意的数字，包括0也包括9；
空白符表示的是肉眼看不出来的有space与tab
4,身份证号的写法
[1-9][0-9]{14}([0-9]{2}[0-9xX])?
5.电话
[0][0-2]{2}([0-3])?[-][0-9]{8}
[0]([])
6.邮编
\d{6}
7.\d\D-----数字\s\S-----白
8.\w(包括_)非特殊\
9.^开始（取反）---结束$
4.5DOM高级=================================================================
1.常见对象的创建方式：new Object（）；2字面量3.自定义构造函数！！！函数啊亲~·~
2.原型：每个构造函数都有一个prototype属性，这个属性也是一个对象，原型，程序员使用。
3.具有--prototype--的都是对象，但是函数也有这个的话，就也是对象。
4.组合继承与构造函数的原型继承都是通过两种方法结合得到上一级级的属性与方法，第一种是构造的可以new出来的函数的this'的值，另一个是原型的点出来额函数的方法。
5.闭包值的是拿到本来拿不到的值与属性，在局部变量中，值是在外面拿不到的，可以通过在函数局部使用return的方法，把局部变量释放出去，但是却不会使初始数据改变。
4.8jQ01================================================================
1.在webstorm中，使用jq智能提示额是方法，使用DOM智能提示出来的是属性；
2.注释在jq的使用中很重要，一般是浏览器出错了，但是却不知道问题出在那里，就可以使用注释的在具体的地方，使用console来检查是否代码执行到了这里，就可以查出问题出在那里，记得是，在这个过程中，需要灵活使用，或者结合断点。
3.在bom中，最外，最顶级的是window，在DOM中最顶级的是document，在jq中最顶级对象是jQuery，怎么理解，就是$(window).load中等于window.onload
4.jq
4.9jQ02====================================================================
1.在jq中使用show与hide两个方法，在后面的括号中使用数值，或者是单词，或者是数字加上一个函数，都可以实现不一样的效果。
2.在使用选择器的时候，有一些选择器不是简单的针对一个或某一个选择，它具有id选择起的作用，就是可以先定向的选择一个你有需要的选择器或者标签，他的使用方式就是，在你的选择器这个使用特殊的用法，这样的用法可以试想的是，在选择第几个。或者悬着这个元素的前民或者后面的元素。
4.11jQ======================================================================
4.12jQ=====================================================================
1.这里之前是一个心灵鸡汤，居然给了别人，这就和尴尬了。
2.在制作插件的构成，要注意的是在自己页面中实现了功能，其次抽离代码，对代码修改，得到一个可以封装的js3.3，吧页面中的生育了也抽离，最后就可以实现多个分，i文件夹的插件知错，其实就是封装函数，再次调用，就是ok。
3.在电泳别人的插件的时候，要注意的是一线的内容，其实就是分开开了，分成五个模板，1--html样式--惊醒修改内容-----2-----css独立文件----修改颜色与自己想要的效果---3----js文件，分别是最小的可以电泳的未知的额文件，其次是可以获取的小型的数据库，自己指搓出来的可以思想详细红能的js'代码块，到了最后还有一个合适我们，就是jQ的最大的数据库，这是那个歌jjs文件都需要引入使用。
4.引入的外部文件，使用的步骤------
5.面向对象的编程思想：
6.几个实用的网站：三百搜，前端自学网，文档伪造。
7.使用jQ的三种方法：
  第一种：使用jQ的数据库，数据库具有多个斑斑
  第二种：使用jQ插件，五个部分，大jQ，封装jQ，调用jQ，结构HTML，css样式。
  第三种：引用UI，先引用UI的css文件，再引入JQuery的js文件，再选择要使用HTML结构，使用搜索的功能区筛选。找到----双击复制---源代码---ctrl+f---找到复制----添加到自己的document中---引入css---引入js---在浏览器打开---成功---修改文本--修改css---添加内部小元素---ok！！！
8.
4.15新老师授课，php==========================================================
1.前端的工资就是很容易就突破一万，优势在于，技术的性质可以在短期得到很大的突破，这个是有条件的，不是说谁都可以达到这个编程，不是或你能说会，最主要的就是你的编程功底，说白了就是技术功底的水平，带白哦的就是你的未来的成就，不是说对比就可以自满，或者自卑，多付出事件，一步一步，没有捷径，尽量的多使用你的时间，目前的时间很是珍贵，需要不对补充这个知识面，不需要有太多的时间去看电影，后者是玩游戏，你的爱好就是听音乐就ok啦，目前学过的的东西就是js，jq，DOM，这这课程的结束，标志着你开始学习更加高深的学习内容，珍惜时间吧，小伙子。
2.团队协作的重要性，首先要注意就是，融入到这个团队中，在团队中，需要进去，在发馈返现自己的不懂得，具体的，概念还是代码，需要的是有价值的反馈，小杨对我们的教官已经过去，不要去抱怨自己，抱怨环境，这些个都是扯淡，包括你自己的私人事情，有些事情，到目前为止，已经是覆水难收。
3.轮在计算机行业中学历与能力·在后期，学历不重要，最主要的是能力。
4.最小的单位是：byte，字节单位，8个二级值大小。老师王自杰。
5.知识点的量化，一理解，二总结，三重复。
6.自己写总结，学到了什么，使用云笔记的方式，可以在手机端使用笔记的回顾。markdown----做笔记的好工具。
7.好记星不如烂笔头，更何况，我们有云笔记。漫漫编程路，方法与努力不可或缺。
8.下集预告：服务器的相关的概念，关于服务器额搭建与原理。
9.php编程语言，万能语言，到底怎么样，看起来就知道了
10，ajax数据库的万能工具，怎么样？惊呆下回讲解。
11.javascript到底是什么？在语言这个领域中，编程语言就是类似于普普通通的语言一般，有着它的语法与规则，但是当两个不一样的对象使用用同一种语言的时候，是不是也可以使用不一样的方式，一类是编译型语言，一类是解释性语言，编译型，就是翻译为文档，解释性语言为一个工具动态解读识别的语言，js中扮演翻译角色的是浏览器中的内核，内核中包括的是js引擎与标签的渲染引擎，js引擎做到的是是程序员与计算机的交流，学会这门语言，控制计算机帮你做事情，这就是编程语言的本质。那么他的工作原理呢？在计算机中笨啦是不认识自己的语言中的文字的，在比脚本语言中，在编译型语言中ccc++、java，oho，c#\都是解释性。编译器针对的 是编译型语言，在编译器中编译代码，可执行为一个可执行的文件，是看不到的没有源代码啊的文件，时期提起那编译好的，不需要计算机最问价二次编译。js是解释性语言，起到的作用就是页面特效，最准确的来讲，就是操作DOM元素，对样式的内容进行正删改查操作，不如制作一个选项卡的项目，使用js来操作dom，bom，eacmacripy，本来拉讲，ECMAscript中js中其实只包括语句，它包括得是变量声明，表达式，语句，循环分支结构，函数，原型，他也是actionsctipt，jscript，flasn语言的标准。DOM也会一种标准，他是规定页面操作元素的操作的规定，bom是浏览器的描述特征，是浏览器特有的。在后期的nodejs，不需要bom与dom。
12.js智能用在浏览器中吗？不是的，他能否运行，是根据他的编译器来讲，只要给他提供了编译器解释器，在学习的过程中，核心是ecmascript，也就是我们的和兴标准与规则。过着中的原型，沙箱，闭包，三大难关的攻克，就是前端大神的成神之路。
13.不得不说，在全端这个行业需要学系的东西太多了。
14.正真的网站开发需要基础知识的扎实来支持，搭建网站，对一个页面来讲，指向的就是一个网站，当我们访问前，这个页面在所属的服务器啊中，当我们访问的时候，才可以在我们的客户端呈现，被下载，在一个页面一般就是结构，样式脚本。在百度的搜索栏使用跳转的过程中，域名是不变的，地址有变化。网站由很多的网页组成，写好的一大堆页面需要放在服务器中，才可以组件一套网站，最终的劳动成果需要分布在服务器中，既然使用服务器，那么杂客户端这里与服务器的关系，就有很大的联系。客户端，不仅仅包括现在的pc包括各种智能终端。区分服务器与交换机的区别一个是，用来存储数据，一个是用力啊交换数据，服务器的规模一般是几千台，一台电脑就是眼前40平凡米，有20厘米厚，他与客户端的逻辑组成一样。在计算机的初期没有操作系统，也只可以使用硬件的自带功能，ibm与盖茨合作，保留合作，不卖版权，相信自己的追求，不要动摇。当计算机走进千家万户的时候，就是开始赚钱的时候到了。乔布斯制作了桌面系统，盖茨一方面合作，一方面自己开发，暗度陈仓···      
15操作系统是使用c语言写出来的，必须是编译级算机，开发成本。在操作系统的下面，使用的是应用软件，必须这样搭配才可以，尤其是在ie6，现在不需要制作ie6的兼容，ie789的兼容现在很少，浏览器具有很好的粘性，所以不需要收费。浏览器的不同，只看内核。操作系统window，mac，linux，在服务器中，操作系统就是linux免费开源，Unix商业版，Winserver主要的功能是执行。net语言。这些都是服务器的操作系统。
16.在服务器端也有很多软件，但是不同于客户端看他的作用是处理与维护数据的。服务器中的网页在阿帕奇中放置，客户端通过网线与服务器的网页去请求与互动，一个典型的客户与服务器两端的模型。
17.软件模型
b/s browser/server 服务器的变更，不需要客户端的软件更新、主流，也最多
c/s clint/server能上网的需要下载的client软件，就是不会自己更新但是需要更新的客户端。费事
18.对于ip地址的分析，字计算机的网络中，ip地址是不可以相同的，否则就会乱，美国控制着ip地址的规则xxx.xxx.xxx.xxx一共有四组，0-255之间，他控制的总数是一定的，新的ipv6数量达到全球每一平凡米所有ip不冲突。但是在网络中，ip一个对应一个或多个域名，这样就是省事。有端口的话，就可以识别是哪一个应用软件，放置串门，目前使用的新端口不要使用1-1024的端口。DNS，是一种解析域名的服务器，整个网络中有13台，解决的是客户端的输入的域名的与服务器的ip地址一一对应的关系，是用来维护公网的dns，或者更新本地的。
19.网络的基本概念：IP地址：唯一的识别互联网的一台计算机。
			域名：与IP对，一个ip可以有一个以上域名。
			端口：区分操作系统的具体的网络应用程序。
20.计算机产业链最核心的是，cpu与操作系统inter垄断cpu，微软垄断操作系统。
21.睡觉的原理，12点前开始睡觉，跟着老师一起学习，知识与习惯。
22.同时扮演客户端与服务器的共性，硬件，操作系统。不同的是软件的不一样，PHPstudent。64赌赢64位，86对应的是32位。
23.Apache是提供网站服务，php是与java平行的后台，mysqe,数据管理，使用这三个进行网站搭建。
24.这种语言中间的公用的一种规则就是双方规定的西街的规则，就是协议。常用的htp，http获取网络资源的协议，https安全的网络传输协议，ftp文件传输协议，smtp邮件发送协议，pop3接受协议。
25.当识别到手机的终端的时候，服务器那边会根据屏幕大小显示不一样的页面。有一套，做了匹配。
26.状态码：页面接受完全200，页面接受找不到，就是404，页面接收服务器端出错，就是505.
27.浏览器的调试中network就是客户端的请求与服务器的回应的显示结果。
28网站的本质：网站是由HTML标签，css样式，js，文字，图片，音视频，网站就是由一些资源组成的。
29为什么我们不使用静态网站，当使用的网站的维护与修改的比较多的时候，静态的就不可以实现我们的需求，比如，在一万个网页中，使用几种广告，这样是不可以人为的修改骨架的，就需要使用动态的网页，最典型的静态网站，就是之前的黄页。web2.0的典型的特性，互联网的内容是上网者产生的，就是在骨架中，由用户自己手动的添加，有计算机自动的添加这些文字或者图片，最典型的就是报读贴吧的自我管理。动态网站的实现需要以下技术：。net在早期现在是几乎所有的处理js的后端语言。之前我们做过的只有图片特效的网站可不是动态网站。动态的网站的本质是数据与交互。
30.为什么我们要使用阿帕奇配置网站的主页，使用虚拟机构建网站的服务器的方法，首先下载wampserver，然后安装后，打开wamp/bin/apache/apache2.4.4/conf/httpd/conf------进去后开始设置DocumentRoot "e:/minAirPerson/"这样的属性------之后打开wamp/bin/apache/apache2.4.4/conf/extra/httpd-vhosts.conf-------进去后设置多个<VirtualHost *:80>
    DocumentRoot "e:/minAirPerson/heyafei"
    ServerName www.heyafei.com
    ServerAlias heyafei.com
</VirtualHost>
这样的模式，如果使用多个主页就需要设置多个viryualhost
4.17php02===============================================================
1.浏览器与服务器，的本质及区别：浏览器是给客户端的客户使用的，服务器是给上网者提供资源的服务的。
2.bs与cs架构，域名相当于名字，ip名字相当于身份证号码。现在使用ipv6，之前的是v4。太长，就起了别名，使用dns服务器，可以实现关联ip地址与域名。
3.重在理解不需要死记硬背。但是关键概念需要记忆。使用两倍的速度，或者1.5倍看录播。
4.写的代码与功能要具有可维护性，后期要着重培养。
5.计算机识别的01的原理是应为，01代表着开关，断开是0接触是1，这样即使通过开断，来识别，是2的n次方，表示的是到目前的为止的10机制的对应下的所有的2进制的编码，集合。存下来的知识0与1,01的储存的格式不一样，就像，一个文件已不一样的格式打开，内容是不一样的 。就是编译的软件不一样，在我们看到的结果就是不一样。
6.1k=1024Byte=1024*8bit.带宽中的M值的是bit，是实际的数值除以8，电脑存储的转化为Byte。
7.baidu.com===这是主域，也就是顶级域名，子域是前缀，www-api。
8.jQuery的常用的修改节点，就是常用的api要使用的熟练，---开发jQuery的插件，熟练的使用别人的jQuery的插件。是基本要求。浅一点就是会用，深厚一点就是知道怎么用的。数组与对象的api的使用要常去查询不要死记硬背。
9.idewenbsorm在联网的情况下，会进行数据的交互，webstorm在内部帮我们启动了一个服务器，在内部打开网页与外部打开，开头是不一样的。
10.所有的额计算机都是使用127.0.0.1来使用的，不需要在使用127这个，使用对应的域名的，可以打开已经储存的网站与网页。
11.在使用了新的服务器定向改变，就不可以继续使用，之前的www。
12.在jQ中的选择器的筛选的包括多种，比之于css最大的不同就是有了更加景区的选择，比如可以加上$("input[name]='name1'").css();这样的形式就是可以选择性的挑选。
13.php的使用：浏览器的工作原理的再一次重申，浏览器获得url地址，对应一个ip地址，服务器得到请求从页面开始检索文件，对于不可以识别的php语法，从服务器中的解析器解析文件，解析之后服务器形成静态页面，发送给客户端。
14.netWork----doc0------后面的就是服务器中的该页面中的源代码的非压缩代码。
15.php的语法结构：
	变量声明：以$开头，变量名必须是以字母数字下划线组成，不可以以数字开头。echo表示输出到静态页面中。需要注意的额是所有的php代码必须写到body标签中。下一次使用必须继续加上$。
	数据类型：基本类型：number，string，boolean，null，undefined，---复杂：object。引用类型（复杂类型）:（Array，Math，Date，String，RegExp，Object，Boolean，Function，Error，Number）
	语言类型：弱类型的语言，跟js一样，也是可以动态的改变变量的声明，
	
16.讲到了多维数组：二维的数组就是在第一个数组中加入到的元素还是数组。
17.在php中双引号可以解析$下面的变量，单引号就知识纯粹的字符串。
18.在动态页面中通过php添加内容的话系可以使用两种方法，一种是直接早php中添加字符串包括标签，另一种是在两个分割的php中，在中间的标签中添加一个php，在这个php中直接使用字符串的拼接，这样的话不需要使用标签的拼接就可以实现动态添加。两种方式需要分情况使用。具体的语法需要去使用，需注意关机的语法内容是不可以变化的。
19.关于在玩野中乱码的情况怎么解决，一般在别的编码的环境下，编写了代码，在另一个编码环境下实现编码的翻译，就会产生乱码。GB2312表示简体字，GBK表示繁体字，utf—8，Unicode编码已经可以表示全世界的素有的编码。在我们存储的时候与显示时候的编码要一致。
20.理解动态页面的执行路程，就是aphaca。使用php声明变量，，拼接字符，使用分支循环，使用php的数组，一种是索引数组，另一种是关联数组（=》）。二位数组，或者多维你数组，常用的内置数组，count，array—pop。push。echo，print_r,var_dump,for(,,,),foreach( as =>),参数的传递，前端的角度主要是请求方式get/post。从后端的角度来讲就是_GET[]_POST[].使用php的基础实现动态网页，就是使用一个二维数组，进行forin循环，得到每一个属性值，在标签中使用'.xxxx.'这样的形式，获得动态的数据，减少了框架的代码量，也是灵活性与可变形。
4.19ajax03===================================================================
1.php的基本流程：请求，处理，php解析，返回静态页面。
2.php的数组与js的数组的求别就是多了一个=》其他的没有什么变化。
3.交互的方式是传参，一种是客户端发送请求，带消息过去，比如查询天气，在服务器中，的到客户端的信息，时间，城市，这种使用get的交互性的请求方式，另外一种，是post，比如博客，发表之后，通过post'的方式存在服务器上，博客就可以被多次访问。还有url地址的长度最大是8000。我们通过表单实现前后端的交互，前端页面中引入链接来接受后端的收据文件。常用的几个传参的方式，form，a，link，script，img.
4.浏览器与服务器得之间通过网线连接，在浏览器中发送求情，在服务器中有一一对应的文件返回，当我们请求的是一个php文件，在服务器中会找到apache，但是apache解析不了，就会交给php解析器，解析后，形成了一个可以识别的静态页面，这是服务器就返回到浏览器中，之后，浏览器对这个返回的静态页面进行渲染，看着就是我们要得到的页面最终效果。所以说，后台的数据，是只至关重要的。
5.什么情况下使用get什么情况下使用post，在不需要保密的时候就可以使用get，但是涉及到保密的情况就是使用post。
6.在php中是使用字符串的拼接，举一个小李子，在js中的字符串的拼接时提前有一个‘+xx+’这样的形式，但是在php中，使用的也是一样的方式‘。XX。’，最需要之一的还是，怎么在两个页面中精确的实现数据的传输。
7.php中的二维数组的使用，比之于js的数组有什么是不一样的额呢？在php标签中，先创建一个具有关联号的额数组，形式是array里面有键值对，不管会显性 的还是隐形的，就是索引对应的值，或者是属性名喜迎的属性值。二维数组的构成，可以使一个数组中间加了一个数组数组中的元素就是多个新的数组，新数组的构成可以使纯属组，在便利的时候就可以使用foreach，在循环中使用得到的额值的索引的输出就可以，也可以是内内部添加的的关联数组，管理数组的遍历不同于村数组的遍历，需要在内部as=》这样方式得到他的对应的属性名，在内部循环还要在添加一个新的循环，在洗的循环中使用遍历到的上次的value，这样就到达了信号的属性值，这样才是可以使用的。
8.php中使用“”遇到字符串，就不需要拼接字符串，直接变量扩在“”中间，就可以实现变量内容的拼接。
9.php调用的时候，使用call---apply这样的两个方式直接使用变量名字的（）来调用，使用call后面的第一个参数是null，第二个之后使数值的，apply第一个是null或者{对象}'，第二个是数组。
10.第五次学this的使用，谁点出来的就是谁，this如果没有实例对象或者其他的，那么就是window，在全局作用域中，不包括局部，所有的属性与方法的上级都是window，在使用call或者apply调用一个可以传参的函数，this的指向是可以变化的。
11.浏览器输入url地址回车--浏览器根据域名去解析ip地址（dns）--去本地的host文件中查找域名对应的ip地址--如果能找到，就返回对应的ip地址--如果没有找到，就去公共网的dns上面寻找--如果所有的dns都没有找到--就报错-404-505--找到之后就返回对应的ip地址---找到之后根据ip找到所访问的服务器---根据端口定位到访问的服务器应用软件（apache，nginx，tomcat）--apache根据请求的路径查找对应的服务器资源---如果找到了请求死php页面，那么久转到php解析器，--php解析器进行处理解析---如果php页面中操作了数据库，那么php页面连接数据库，并且操作，渲染到页面---php最终转化PHP页面为静态的html页面，返回给apache。----apache接收到静态页面资源后返回到浏览器----浏览器接收后，渲染页面，进行js脚本的执行。=----用户就看到了最终的页面效果。
12.http协议的无状态？一次请求就是一次会话，请求后就结束了，下次访问的时候就不知道有访问了多少次，这就是用到了cookie，就想买10送一，这个卡片就是cookie，在客户端存储，但是有安全风险，可以被伪造，cookie可以存储的东西少，这两个缺陷。服务器与客户端的编号的一一对应就是session。http没有记录功能，就出现了cookie，用来维护客户端与服务器之间的状态，有些不法人员扫描用户的访问数据，用来分析用户的信息。存储 的大小是4k，那么我们怎么去使用呢》使用原生的js可以控制cookie。cookie与域名是绑定的，不可以从一个域名中去获取另外的域名下的cookie，这是规则。获取的方式：document.cookie.获取的是所有的cookie。cookie的存储格式是键值对（key=value），多个cookie使用分号隔开，（username=tom； age=12；）设置cookie的值的方式：document.cookie="username=Carlfied; age=12;";知道了cookie的设置，也知道了cookie的获取，cookie的分类：1.会话cookie，之存储的在内存，不会存储到文件中。浏览器关闭之后就会消失。2.持久cookie，（插件editecookie）可以获得cookie的详细的数据。当我们使用封装函数，foe循环，if判断，return，外部调用，传参数，就可以定向的获得cookie的值。或者使用封装的函数可以设置cookjie的键值对，过期时间expies=""; path="/"。
13.前端的工作，动态页面与接口。对于多个人员的共同使用与
14.使用session的方式，当服务器的访问数量太大的时候，就可以使用负载均衡，就是使用分服务器来分担主服务器的压力，而且也是可以进行数据的实时保存的，分服务器也是有备份服务器一一搭配的，当分服务器宕机的时候，备份的分服务器立即开始启动。session的作用，会话cookie被保存在浏览器中，使用cookie可以配合浏览器智能选择跳转的网页，比如，在京东网站所有的网页下，一个session会公用，就不会产生抑制输入账号与密码的问题，也不会产生直接打开连接就可以实现的登陆的bug。
4.20ajax======================================================================
1.1.display2.宽高3.bgc4.最后选择标准或者浮动，或者定位模式估计数字，网页调整。5.font
2.元素脱标会在z轴上有数值。z-index设置值的顶部高度。
3.网页中使用img还是bgi，页面中都是字符串，请求服务器，下载，客户端解析，呈现页面，字节越小，网速越快，这是一个，后台可以生成。使用bgi。
4.记得定位除了数值位置，还有center，top这些方位属性。
5.position：absoluted；下方，设置top：0px、left：0px与默认设置是不同的效果，设置了00，以浏览器为坐标，不设置以父元素为坐标，导致，最终位置是不同的。
6.两个标签的覆盖：伪类中使用：after，元素显现是在最后的，可以覆盖，使用before，呈现在最前，可以被覆盖。
6.div的叫法：标准叫层，通俗叫盒子，实际上，div里面的标签是在div上面叠着。
7.使用z-index的方法
8.li中的a使用技巧：li设置行高，一般来说，a值设置颜色字体，宽高是li标签的来设置。
9.span的使用技巧：一般用来使用标点符号的样式。
10.color：标注叫前景色
11.100xx%百分之多少，值的是父级元素的百分之多少
12.等级太低的话，选择三个字母起类名，不要太少了，难以找到。
13.协议不跳转，轮播图。
14.基础的知识，一定要打牢，面试也工作都要用。
15.div+css布局，就是注释加类名加盒子。
16.最大的盒子，以及包含盒子多的大盒子，就不要使用撑开来呈现盒子的宽高。
17.用户信息的头像就是img
----------------------------------------------------------------------------------
js
1.代码遇到问题，优先调试。
2.命名规范：英文或者拼音的全拼。
3.注重基础，以最简单的案例解决问题，以企业案例进行实践。
4.js有小bug，不要转牛角尖。
5.有疑问及时询问，或者积累。
6.三种注释：
7.异部与同步：
8.变量的声明与规范。
9.五大浏览器：谷歌，火狐，苹果，opera，ie。IE（8）最bug，牢记常见的浏览器的兼容问题。国产浏览器中的
佼佼者，就是uc，最重要的就是谷歌，ie，火狐。
10.浏览器中具有解析器：可以解析HTML，css，js。相当于一个翻译。
11.首先打开，看到的是用户界面，浏览器引擎处理，可以持久性存储数据，但是，长时间不适用，会被电脑清除
	其次，显示内容，解析css与html，都绘制出来的，浏览器所有显示出来的界面，都是绘制出来的、
12.浏览器的组件：
13.浏览器的工作原理：
14.javascript：
	ECMAScript：基本的语法与对象标准。
	DOM：文档编辑
	BOM：对象编辑
15.API就是一种方法，使用其他做出来的成果，放置在自己的程序中，就可以显示实现自己的功能。
16.程序本来是要编写代码，在进行进制编译，才能识别，现用的都是高级编程语言，最高级的编程语言
	就是c语言， 编译就是高级编程语言转化成为计算机语言，我们学习的js是不需要编译的，是一门
	脚本语言，这就是js的脚本原理。c#，java，ios三种语言大同小异。在计算机里面计算机存储
	具有一定的限制。
17.认知当前的变量到底是什么类型。脚本（不编译，直接运行在命令行中），弱类型（var），动态型语言（识别当前的数据到底是
  什么类型）。
18.系统具有不同的版本，同一个程序，在不同的系统的中不一定可以跨平台，但是js是可以跨平台的
  ios开发，anduod，设计，后台，都可以使用交互，特效，开发。
19.  布莱登.艾奇，十天的时间，设计出来的，ECMAScript，宣传时间，借用的java的名头，导致现在依旧在
宣传，没关系。
20. js最初的目的就是解决浏览器与服务器之间的交互，比如，密码的强弱检测。
21.  展示信息，美化页面，计算能力。可以的项目：游戏，小游戏，页面，网页版的简历特效，博客园老师也在。
22.  html极速3d立体式相册制作：网络教程上传、
23.  js：在页面中进行验证，计算。是脚本语言，cmd，vbscript，却别之处，边执行，边编译。
24.  IDE：集成开发软件。（sublim，webstorm，visual Studio）没有高亮显示，没有自动换行，是记事本写代码的坏处。
25.  js点出来的东西与点不出来的东西：智能提示的东西可能不可以使用，智能并不提示的可能可以使用
  动态的解析，值的是在运行的时候才可以识别的语言类型是什么类型。
26.  js注意点：
  26.1变量具有大小写之分，var a=10；console（N）；
  26.2弱类型语言，定义变量，都是var
  26.3字符串使用单引号与双引号都可以，只有在与DOM一起使用的时候才可以使用单引号。
  26.4每一句代码结束后都要使用分号结束，不使用可能会出现不同的结果。
  26.5js中的注释：对代码的解释，相当于对文言文中的翻译。单行//多行/**/
27.  js代码script标签可以写在，但是要写body下最后面，好处是加载页面信息，最后加载js，速度快
  而且用户体验最好。就算放在html后，浏览器也要执行一次把js代码放在body中的工作。
28.  写法：
29.  数量：在页面中可以有多对js代码，第一行代码出错会影响当前的代码不会影响带后面的js代码。实例：
  引入：
30.  异步与同步：
  异步：多个人同时做多件事：js代码一边执行，一边下载，下载完毕，开始执行
  同步：一个人有顺序的做多件事。js代码中。上下显示，按照顺序。
31.异步的两种用法：async：页面开始加载，开始下载。下载好就开始执行。defer就是页面加载完之后
  开始下载，下载完毕后开始执行。
32.js的type：第一：在xhtml中要使用text/javascript，第二：h5中不需要写text，第三：language属性
  是在外部广告。
33.交换两个变量的值：1.第一种;第三方变量的方式，var mun1=10;var num2=20;var temp=num1;
  num1=num
  2，加减法：
  3:位运算，异或运算。*使用二进制10 1010 20 10100 30 11110 * var num=10; var num=20;(相同为1，不同为0) num1=num1^num2;（30
）num2=num1^num2;（10）num1=num1^num2;（20）console.log（num1,num2）;(交换结果)
34.  命名规范：1.英文数字下划线，$组成，开头不用$。2.驼峰命名法，第二个英语单词开始首字母大写
  3.初始化变量，使用多个赋值一次var声明就可以。
35.  判断名字或者范围使用boolean值，ture或false，1或0，真或假；
36.  undifined的情况：一种是声明变量但是没有进行赋值，另一种就是运算了返回值就是undifined。
37.  mul的情况：清空或者赋值。
38.  typeof（变量）显示变量的类型：num。str。flag。def。nul。obj；注意的是null的类型是object，null的值是null。
39.  两个类型的值在计算的时候是没有意义的：想要使用变量，最好先判断类型，是不是undifined或null
40.  蓝色是数值，黑色是字符换，经验而已不是标准。需要在控制台中判断值是否相等，使用单引号，双引号
  是不可的。第二种就是外边是双引号，里面就是单引号。
41.  NaN非数字，可以用来isNaN判断布尔值。
42.  var num=0xa; console.log(num1)(值为10)；这是控制台对所有进制的数值都会转换为10进制，
  在js中不可以进行别的进制的数据储蓄。
43.  js中的小bug，在存储小数的时候，小数有偏差，0.1+0.2+=0.30000004；不要测量像个小数的差与值。
44.  Number.MAX_Number()Number.MAX_Number
45.  字符串：特性内容不可变，只可以显示所有的字符串开辟的所有空间的内容。字符串中空格也算一个长度
  有些字在页面中会失效，那些事tab或者\\,只会显示一个\为的是跟上面的一行进行对齐。称为转义符。
46  \r\n\b
47.  加好用在两个字符串之间就是使用字符串链接的一起，两个字符串，就是拼接，一字符串一个数字
  就是字符串跟数字的拼接，数字型的字符串相加就不是拼接？（两个疑问，字符数字，与数值数字加减四种结果）
48.   布尔类型：两个值，false，true数字也可以转换，非0是true，0是false。字符串也可以，非空是true，空
  是false。3.undifined，null都是false。创建一个空的对象没有赋值，类型转换为true，但是给他赋值null
  就成了false。
49.  当一个变量没有赋值，undifined，当一个变量声明了没有初始化，也就是一个意思。返回值undifined。
50.  变量没有赋值，结果就是undifined，在if语句中就会执行else中的语句。
51.  数据类型转换：需要这种类型的值，就需要转换，1.其他类型转数字类型，其他类型转字符串类型，其他类型
  转布尔类型。
  51.1 Number（不管是哪个转换失败就是NaN） parseInt（只要开头的数字，字母开头就NaN） parseFloat（）--最常用的，严谨。
  51.2 parseFloat（0234）返回值就是234，转换的是全部的值，包括小数部分的值。小bug，前面的0会丢掉。8进制？
  51.3Number（）最常用，最严谨，parseInt()少用，比如银行的小数你给丢了，呵呵哒，完了。。。parseFloat不严谨，NaN。
52.  其他类型转换为字符串：数字可以，toString（10）ok。。String（undifined、null）ok！！
53.  字符串的拼接：两个拼接+、十来个字符串拼接的方法？？？？先把一串汉字输好，在那个地方添加变量，就
  在这里一对引号，加+。ok
54.  算数运算符，复合运算符，比较运算符，逻辑运算符。
55.  算数运算表达式：首先是一个表达式，有运算符链接起来的表达式。
56.  一元运算符：++  --  num++ num-- ++num  --num（特点是只有一个操作数就可以进行运算）
57.  二元运算符：1+1
58.  三元运算符：？ ：---》就是if》《=······
59.  复合运算符，复合运算表达式。内容：+= -= *= 
60.  比较运算符，比较运算表达式。内容：> < >= <= == === != !==
61.  逻辑运算符，逻辑运算表达式--。内容：&& || ！  里面一般掺杂着比较运算表达式
62.  a++与++a在遇到下一个运算符的时候必须要显示计算后的值。（重点理解四个计算结果）
63.  ture&&obj=obj···1&&2=2；同理为前面的理论。
63.1 优先级从高到低：（）优先级最高>>>元运算符++>-->!>>>算数运算符>>>*/%+->>>关系运算 > >>= > < > <= >>>相等运算
  == != === !==>>> 逻辑运算符：先 && > ||;
64.  流程控制：控制代码执行的顺序--顺序结构，分值结构，循环结构
  顺序结构：代码从上到下，从左到右（赋值=是特例从右到左）执行，
  分值结构：if语句，if-slse语句，if-else··if-els···语句，switch-case，三元表达式；
  if语句：if（表达式）{·代码段·}先判断表达式结果是true还是false，如果是true就执行里面的代码段，否则不执行大括号的
  代码段，直接执行大括号后面的内容。一般使用if语句就可以了，不需要if else语句的时候就不要这样使用。
  if-else语句：语法：if（表达式）{代码1}else{代码2}；判断表达式的返回值是true，执行代码1，false执行带吗
  这就是三元表达式：表达式1（或者值）？表达式2（值）：表达式3（值）；最多三个--
  var max=num1>num2?(num2>num3?10:8):(num1>num3?90:88);(这是三对)
  var if(num1>num2){if(unm2>num3){10}else{8}} elseif(num1>num3){90}else{88}}；三元的if-else
  if三种语句的使用范围情况分别是：一个树枝if，两个树枝if-slse，很多树枝，if-else if--ok！
65.  switch-case：语法结构：switch（表达式）{ case 值1：代码1；break； 
							   case 值1：代码1；break；}
66.  有new就是创建一个对象，案例根据日期判断惊天是星期几？
  var dt=new Date().getDay(){case 1:console.log(1);break;  case 1:console.log(1);break;  case 1:console.log(1);break;
  case 1:console.log(1);break; }
67.  当case中间具有多个case符合值的情况，只执行第一个case，只有当符合第一个但是第一个没有加break
的时候，才会继续执行下面的case，这就是案例月份。
68.  给定一个变量判断变量属于哪个范围--
  var dengji="x"; switch(dengji){case "a":console.log("0-30");break;  case "a":console.log("30-60");break;
  case "a":console.log("60-90");break;  case "a":console.log("60-100");break; defout:console.log("no-search");break; }
69.  循环结构：同一行代码不停地执行，执行多次，包括;while循环。。do-while循环。。for循环。。for-in循环
  理解层面：开枪i=0;段哥跑步i++;，小杨计数i<=20;,语法结构：i=0；while（i<=10）{代码}
  理论：先判断表达式是否成立，成立的话，就开始执行内部代码，否则直接跳过循环。
  成立的情况执行内代码的i++----案例：使用while语句计算1-100之间所有数，所有奇数，所有偶数的和
  var i=1, sum=0; while(i<=100){if(!i%2=0){sum+=i; }i++; }
  再看一个死循环的案例就是不使用范围圈定。//提示用户输入一个账号与密码，账号是admin，密码是123，否则提示重新输入
  var userName=prompr("请输入您的账号")，userPwd=("请输入您的密码")；while(userName="admin"||userPwd="123"){
  您的密码或账号错误 } console.log（"登陆成功"）；
70.  //while-if-bresk语句可以用来寻找第一个条件的值
  var i=1; while(i<=200){ if(i%7==0){ console.log("i") } }
71.  //while-if-continue语句可以用来寻找所有条件的值的和
    
72.  while循环的特点是先判断后执行，有可能就是一次都不执行循环，do-while是先执行一次代码
  //使用d0-while来实现用户的密码与账号登陆与直接使用while循环的区别在哪里？
  var userName=""，userPwd""；
  do{ var userName=prompr("请输入您的账号")，userPwd=("请输入您的密码")； } while(userName!="admin
"||)
73.  三种变量的交换，三遍=======if中计算年龄的案例=======判断年龄的，判断成绩分数段if-else
  根据当前的时间显示星期，根据级别显示分数，===输入数字显示几位数===计算100以内所有，偶数，奇数，
  所有能被7整除的数==break跟cotinue做一次值与所有值的案例===只要不输入y就一直问我：我帅不帅
  ===账号和密码的判断：while与do-while。
74.  null是一个object类型
=======================================================================
js第二天
1.js代码与其他代码混合在一起，就是单引号好。
2.js写法，内嵌式，内联式，外链式。不要在外引入的js文件的script标签中写代码。
3.逻辑运算符中的表达式true与false的返回值，是短路原则。只有赋值是从右到左。
4.只要其中之一，if就够了，要有两个结果就是if-slse或者三元表达式，多对区间if-else-if。对于多个值，取多个区间，就是用switch。
5.在输入的数字的前面需要使用Number，或者parseInt来转换字符类型。
6.while语句与if语句的嵌套可以相互交叉--案例：求位数
var num="";

7.for循环：必须添加的几个语句，i++否则陷入死循环，声明一个i=""，否则进不去循环的条件。运行原理：（var i=0;i<=length;i++;）{ 循环体 }。
小案例：输出哈哈我又变帅了
for(var i=0;i<=10;i++;){
	console.log("我又变帅了")
}
三个表达式是可以省略的，省略就是死循环。
//求1-100之间所有数字的和
//定义变量，存储数字的和
var sum=0;
//循环求和
for(i=0;i<=100;i++;){
	sum+=i;
}
console.log(sum);
//控制台输出结果
------------------------------------
//求1-100之间的所有的奇数的和
//定义变量，存储数字的和
var addSum=0;//存储奇数的和
var evenSum=0;//存储偶数的和
for(i=0;i<=100;i++;){//添加if-else语句
	if(i%2!=0){//这是奇数的语句
	addSum=addSum+i;
}else{//这是偶数的语句

	evenSum+=i;
}
}
console.log(addSum,evenSum);
----------------------------------
//已知本金和利率，求5年后的本金与利息，使用0.003不要千分之三，本金10000元存入银行，利率是千分之三，每过一年本金加利息，再进行计算，计算5年后的本金加利息//
var money=10000;
var rate=0.003;
for(var i=0;i<5;i++){
	money=money+money*rate;//下一年的本金
	money+=money*rate;//money=money+money*rate,
}
console.log(money);
----------------------------------
//斐波那契数列：黄金分割数列，可以计算兔子的繁殖数量,期初有两只兔子，
var num1=1;
var num2=1;
sum=0;
for(var i=3;i<=12;i++){
	sum=num1+num2;
	num1=num2;
	num2=sum;
}
console.log(sum);
----------------------------------
//一到五之间所有数字的和断点调试
var sum=0;
for(var i=0;i<=5;i++){
	sum+=i;
}
console.log(sum);
-------------------------------------
//打印九九乘法表
document.write("<table border='1'>")
        for(var i=0;i<=9;i++){
            document.write("<tr>")
            for(var j=0;j<=i;j++){
                document.write("<td>")
                document.write(j+"X"+i+"="+j*i);
//                document.write("<br />");
                document.write("</td>");
            }
            document.write("</tr>");

        }
document.write("</table>");
--------------------------------------
8.数组的作用：可以一次性存储多个数据
数组的元素：存储的每个数据。
如何获取数组的元素的值？
如何设置数组的元素的值？
--通过索引（下标 的方式来设置数组的元素的值）
数组如何定义？
三种方式:
var 变量=[ ];字面量的方式定义数组
var 变量=new Array();构建函数的方式设置数组
注意：js中数组是可以设置长度的
	数组中每个元素都是以逗号隔开的。
	类型
原理：栈与堆：让时间倒退，使障碍物消失，现场再次恢复时间，恢复现场。
	栈--有序的上下存储空间（入栈从下到上，出栈，上到下，加一次值，开一次空间）--编号（有序的集合，从下到上，0-oo）
	堆--无序的杂乱空间--
数组是存储在栈空间的，取值叫获取--赋值叫设置；
获取----
var num=[10,20,30,40]
var result=num[2];
console.log(num);==30==
设置----
var num=[10,20,30,40];
var[4]=[50];
console.log(num)//num=[10,20,30,50]
数组的长度是可变的
var arr=[1,2,3,4,5,6,7]
arr[7]=8;
arr.length=8
空数组后面的数值是长度（），但不是空数组，已经开辟了空间
var arr=newArray(3)--表示数组的长度是3
var arr=newArray(3,5)--表示数组的元素是[3,5]
索引（下标）==个数-1；-------注意下标的最大值是length的值-1
var arr=new Array(num);//长度是num
var arr=new Array(num，num2);//这是数组的两个值***
数组可以一次性储存多个同类型或者不同类型的数据
var arr=[1，undifined，null，"hellow",1233];
//提示输入人数，根据认识求班级每个人的成绩，再求所有人的成绩和，与平均数
for(var i=0)
 
//1.求数组中的和，平均值，最大值，最小值
//数组的最大最小值，总数，平均值
var arr = [20, 90, 76, 44, 77];
var sum = 0;//
var avg = 0;//
var max = Number.MIN_VALUE;
var nim = Number.MAX_VALUE;
for (var i = 0; i < arr.length; i++) {
    sum += arr[i];
    avg = sum / (arr.length);
    if (max < arr[i]) {
        max = arr[i];
    }
    if (nim > arr[i]) {
        nim = arr[i];
    }
}
console.log("最大值是：" + max + "最小值是：" + nim + "和是：" + sum + "平均数是：" + avg);
----------------------------------------------------------------------------------------
//2.将数组的每个字符串元素用”|”竖线的方式隔开，并输出

//3.去掉数组中的0，产生新数组。
        //4.实现反转数组
        //5.根据输入班级人数依次输入每个人成绩,求总成绩和平均值
        //6.随即生成10个1-100内的非重复数字放入数组中。(调用系统方法)
        //7.求一个工资数组中，员工的最高工资、最低工资、平均工资
        //8两个数组{ “a”,“b”,“c”,“d”,“e”}和{ “d”, “e”, “f”, “g”, “h” }，把这两个数组去除重复项合并成一个。
写一行代码求班级的人数与班级的平均数------------------------------------------------
        var pers=parseInt(prompt("请您输入班级人数"));
        var scores=[];//
        var sum=0;
        for(var i=0;i<pers;i++){
            scores[scores.length]=parseInt(prompt("请输入第"+(i+1)+"个同学的成绩"));
            sum+=scores[i];
        }
        for(var i=0;i<scores.length;i++){
            console.log("第"+(i+1)+"个人的成绩是"+scores[i]);
        }
        console.log("总成绩是"+sum+"分，平均成绩是："+sum/pers+"分");

9.函数：把需要使用的代码段，封装在一个变量中，需要的时候直接调用就可以。
作用：可以重复使用
定义：dunction 函数名（）{
		函数体；
	}
	//调用
	函数名（）；
	切记：目前函数首字母不允许大写。
4.20ajax=====================================================================
0.数组，字符窜拼接，函数，循环一分支语句。
1.总结回顾的事情，设置cookie，获取cookie，改删cookie；session也是一样。
2.隐藏帧的技术实现的异步效果-iframe--在一个页面内部嵌入一个子页面。实现的原理就是不使用主页面的刷新，而是局部刷新，不影响用户的体验。在子页面的内用也可以在主页面的控制台中显示出来。子页面可以操作父级页面，真实没谁了！！
3.之前使用的隐藏帧的方式做出来的是一个假的局部刷新，要使用js的语法实现真的局部刷新，需要使用ajax，ajax的请求是真正的无刷新，。
4.需要注意的是所有的服务端传输过来的都是字符串。1.当使用判断的时候，注意是使用===，还是==。这是不一样的，2.字符串过来的数据需要使用split的方法对象添加，循环，来吧数据进行转化。一般情况下我们不使用转化。
5.使用ajax跟php判断的方式相结合，可以达到最好的组合。
6.浏览器的readState码会改变（0创建就是初始化完成,1发送动作,2完全返回,3正在解析,4解析完成可以使用），但是浏览器的返回状态码--200正常---404--找不到资源---500--服务器出错。
7.使用异步先要创建一个状态准备改变的对应值，使用兼容代码，有则创建-----在进行open（）打开要循环找的php文件，有传输方式，文件后缀加上字符串，友布尔值------状态值每次改变都会产生一个0-4的状态值------返回的值获取方式只有一种resontext----根绝这个返回值进行判断执行代码中的需要使用的条件语句-----判断是条件的选择就是两层判断或者是一个&&判断。
8.一个很重要的问题，就是在php的引用或者是直接使用的时候，不可以把php放在中文下面，相对的，什么时候可以使用中文呢？在页面中使用中文的时候要注意能不能解析为特殊的字符。
9.自己做一个函数，可以传参数，可以定制任何的数据类型。
10.课程思路：静态网站与动态网站都是同步的，同步有自己的缺点，同步是阻塞式的，影响用户体验，可以通过变通的手段实现页面额局部跟新，一种是隐藏帧技术，由于上述方式是使用iframe，总是有一个元素存在，就诞生了ajax，就是处理异步。从而可以实现页面内的局部更新，就是使用php，在script中使用1.创建一个XMLHttpRequset对象xtr-----2.准备发送参数xhr.open("get/post","路径")------3.执行发送动作send（null如果是post就不可用null）-------4.这里是重点得到php或者其他后台但会的数据，需要进行解析。
11.怎么进行解析？1.请求的方式get、post------2、相应的内容：xhr.resposeText;对这个返回值进行json遍历。
12.url标准格式：scheme://host.domain:porrt/path/filename
4.21ajax02===============================================================
1.浏览器的调试器中的网络模块，主要是是sever，cookie，doc下的响应头与发送请求的请求头，上节课初步接触到了ajax，使用动态网页与apache铺垫，体会到了传统的网站的开发和响应的方式都是阻塞式的，被阻塞的是浏览器，产生阻塞的源头是服务器的卡顿，这样，早期使用隐藏帧的技术，解决了用户主页面不刷新，变通的实现页面的局部更新，原理就是在子页面中使用iframe，由于上述开发不方便，后来浏览器就支持了一步开发。
2.使用ajax实现请求响应处理，在ie678与更高版本的ie与心得其他逐鹿浏览器，都有xmlhttprequset的方法来实现这个方法就是我们的ajax实现请求响应处理的核心，1.创建。2.配置。3.发送4.处理响应（即一个onreadsttechage这个函数，来处理后台传过来的状态值与状态码），当我们知道了这个过程，在第一个页面中，使用静态的页面开始交互，在默认与非默认的表单中可以使用数据的提交，但是不要跟ajax的请求过程混为一谈，表单可以submit或者在js中使用submit（）；return false这样。另一种就是之前的ajax的提交数据，早open中，3.单纯的使用url线束来进行数据的传递，这个当时是get。
3.那么，ajax是怎么来发送与响应请求的？我们使用过的就是post与get，这是发送请求，响应请求就是返回的数据我们进行处理，返回的是xml与json，1.首先xml也有自己的格式里面有标签，而且浏览器也可以解析它的便签，但是问题在于冗余标签太对占据了主题内容很大部分，标签的格式可以使自己可以理解的类似于编码的形式，2.json----就是一个标准的字面连对象{},需要注意的是，在json格式中，{“”：“”，“”：“”}这是严格的数据样式，就像二位数组一样，在对象中也是可以有数组，里面依旧可以是对象。但是直接二位对象可以吗？脑瘤疑问。
4.在后期的工作，但部分是请求数据，返回页面，渲染页面，这是我们大部分的工作内容，就需要使用函数的回调。回调函数本身是"他人"调用自己的函数，不是自己调用，"他人"指的是别的函数或者是浏览器在别的环境中使用这个函数，说白了就在在另一个函数中使用自己的函数，把这个函数体作为参数，在另一个内部进行形参的调用，这就是回调，跟自调用（沙箱不同），在定时器中使用沙箱可以无限制的一直执行沙箱，最方便。它的实际意义在哪里？实参，形参，里层参数称为外层函数的参数--这就是糊掉的逻辑结构。
5.因为在我们只作为一个或者多个函数的时候，需呀注意的一点就是文件的分类，建立一个主目录，注意名字不要使用汉字，识别不出来的，封装一个个ajax函数，有四个参数，type,url,param,callback,第一步创建一个xhr对象，需要存在性判断，1.先要声明，xhr=null；2.在进行if-else语句创建两种兼容效果，3.准备配置参数，需要注意的是早url后面需要使用+‘？’+在url后面跟着我们设定的参数变量如果是get获取，就住在前面判断一个prama为null，4.处理响应的返回结果，两种方式，在html中，使用一个回调，即之多一个函数传参给封装的函数中。
6.怎么处理我们通过回调得到的结果？encodeURI编码--decodeURi解码！当我们使用了js执行就是单线程执行，在使用定时器与onreadstatechange（）这个函数的时候，前面的语句没有结束后面的语句会被阻塞，这就是为什么我们要使用异步！
7当我们返回的是一个字符串形式的代码。使用eval（“xxx”）的形式就可以执行这一串代码。
8。ajax的使用意义就是，指向一个url，这个文件输出的结果就可以传给我们的html源文件，执行返回的数据，怎么处理呢？使用callback的参数，使用一个灵活的函数，这个函数的参数是data，在函数内部，将data的属性与方法进行console或者是html（）或者是innerHTML或者是innerText来打印或者输出，之前学过的innner，ducument.write，或者是createElement（）或者createTextNode（);
8.回调函数的使用注意事项：一个是：当我们使用了一个参数后，还要接着使用下一个功能，但是还必须使用在这个大的函数内部，就可以使用回调函数来实现，另一种做法是：我们在使用含糊是内部的数据的时候，需要把这个语句放在我们回调的函数中才可实现数据的读取，因为在全局变量中，有限执行的是没事件的全局语句，那三个有事件的函数需要放在事件队列中去，而且，对于事件u队列的函数，我们想要实现，也要放在事件队列中，为了实现目的可以使用一个0的一次定时器settimeout，但是使用在一个ajax的callback函数中岂不是更好？
9.防止默认事件，首先，什么是默认事件？指的是但我们点击或者只执行一个动作的时候，系统默认的下一步就是默认事件，有时候我们想改变他的指向动作行为，或者是我们想要停止这个动作的时候，就要使用放置默认事件，默认事件的使用方法就是在函数内部，或者标签的后面加上一个语句return false：！！！这样就可以截断他的执行。
10.假设我们想要一个需求：获取所有的表单下面的只有input这个标签的属性值并且不要打印在页面！首先我们在使用ajax的时候不想要对象的本质是什么？$('form').eq(0).serialize();这样的话，$('p')eq(0)与$('p')[0],当我们使用一个jq获得一个标签选择器的时候，得到的这个元素就是类似于数组的内容，他是一个有数组特点的jQuery专属的数据类型，但是本质是一个对象，必须有索引，必须与length。这就是使用application programing interface（api）,复习一个知识点：DOM对象与jQuery对象的相互转换get(0)=this.在函数外使用return false就可以截断。
11.扩张一个知识点：addeventlisterner（“click”，function）-----DOM======on/bind（"click",function）-----jQuery===========这里需要注意的是：在这两种情况下，阻止默认事件e.eventdafult，而在一般的事件代理直接使用onlick中使用return false,就可以实现了。对象是什么，对象就是无序的键值对的集合。
12.模仿jQuery的$.ajax()的实现封装：
function ajax(obj){
	//默认参数
	var defaults={
		type:'get',
		data:{},
		url:'#'
	}
	//1.创建xhr对象
	var xhr=null;
	if(window.XMLHttpRequst){
		xhr=new XMLHttpRequst;
	}else{
		xhr=new ActionXObject("microsoft.XMLHTTP");
	}
	//2.配置发送参数
	xhr.open(defaults.type,defaults.url);
   //3.执行发送动作
	var prama='';
	for()
	//4.处理响应（指定回调函数）		

}
13.再来一个尖端代码：使用forin实现对象的属性的覆盖，数组也是同理。
var defaults={'name':'zhangdan','gender':'male','age':'12'};
var obj1={'love':'conputer'};
for(var key in obj1){
	defaults[key]=obj1[key];

}
4.23ajax03==================================================================
1.上集回放，在上一节课我们讲到，使用封装函数的方法，使用type，url，prama，callback，这是四个参数，使用jQuery目前有个缺点，就是冗余代码多，维护不好，但是为什么，是因为jQ中使用的方法有很大的一部分就是多余的，所以说原生的最大的好处就是，用什么，编程就编什么。jQajax相关的API，ajax，get，post，getJSON，getScript，serislize。使用的格式就是$.ajax({
	type:'',
	url:'',
	data:{},
	datatype:'',
	sunccess:function(){
	
	
	}
	error:function(){

	}
});使用jq的ajax方法不需要按固定顺序来排列参数。自己封装的需要排序。
//=================================

2.使用get与post的方法实现数据的交互，使用get注意URI的encode的编码，使用post注意send（）还有就是setHttpRequst（content-type，“xxxxxxxxxxxx”）；
3.模板引擎：
4.hibgit，arttemplate使用标签与变量属性的拼接，可以使用直接结构的里面添加引号与变量。我们使用模板引擎的作用就是把数据与模板结合，生成静态的HTML片段。使用模板可以生成DOM节点。适应一个模板的script的type为text/html。双花括号里面是条件判断，变量，循环与分支语句。而且这样的花括号都是一一对应的。一个变量转义的意思就是转成字符串。不转义就是转化为带格式的无标签的形式。模板引擎的主要职责就是代替我们之前的字符串的拼接功能。另一个知识点，三个函数，
{{if isAdmin}}
	{{  }}
{{/if}}
5。处于安全方面的考虑，通源策略的限制导致，原生的js-ajax是不支持跨域的，但是jQuery的ajaxAPI是可以跨域的。跨域的条件只有三点，就是协议，域名，端口这三者，其他的不变，就不是跨域，跨域就是得到别的域名下的文件或数据。但是实际上是有这个要求的。跨域的解决的方案是jsonp，原理，后台开发接口，案例----传参的方式一种是直接在url地址后面加上？xx=xx$xx=yy,还有一种就是使用变量ajax传参。呵呵呵，你觉得我信吗？async，异步的意思。采用DOM操作的方式是异步。还是讲到预解析，在函数体内，变量与函数的声明，都会在上方有个变量名存在，同理，函数的预解析与变量的提升是同一个原理。
6.与后台的交互，一个是跨域的获取，一个是ajax获取，一个是模板的使用。明白数组就是对象，因为有原型，也有无序的键值对的集合，还有就是可以点出来的方式设置函数与属性值。
7.跨域的出现，ajax访问不到外部网站，ajax，局部刷新，跨域的原理就是，动态创建script标签访问外域网站链接不会被拒绝。在创建的script的src中使用？传参数，使用script请求方式只能 是get，这个时候就可以餐参数进去php，在html中新建一个script。
4.24跨域与数据库============================================================
1.当我们使用跨域有目的性的封装一个函数的时候，可以这样做：首先，创建一个函数我们一ajax来申明这个函数，接下来，我们要封装这个函数，首先，设置一个默认的对象default这样的，里面的对象包括了之后要传进来的jsonp，url，data这三个对象名，后面跟着空的默认格式，这时，在我们的html页面或者其他的页面中，我们已经开始创建了一个别的对象obj1，里面也是加上了url。jsonp，data这几个具体的属性值，在内部我们设置好的这个封装的函数，开始设置传的参数与默认的格式的覆盖，使用一个forin循环的语句就可以实现，实现的方法是：给defalut[key]=obj1[key],这样就是有的话就覆盖，没有的话，就添加一个新的的属性，这样，我们就得到了一个需要处理的对象。接下来开始处理我们的参数prama，参数使用使用一个变量的形式，最后要拼接我们创建的那个对象，使用forin循环逐次的把data中的各项属性添加到一个字符串prama中，prama+=key+'='+default.data[key]+'&';因为我们得到的字符串的最后一个字符是&，需要使用字符串截取的substring(0.data.length-1)，这样的形式。但是我们常见的url后面紧跟着的参数的传递不是一个简单的参数，为了避免函数名字的重复，我们采用随机生成Math.random()这样的形式，加上 var cbName = 'jQuery' + ('v1.11.1' + Math.random()).replace(/\D+/g,'') + '_' + (new Date().getTime());这句代码的解释就是我们创建一个函数名，名字的格式是一jQuery开头，紧跟着版本号，再加上一个随机数，在后面我们又把所有的非数字从头到尾的使用空字符的方法把非数字去掉，这是一个新的用法，需要格外注意，这个时候，我们已经获得了一个完整的函数名，但是我们创建的一个函数名能不能在后台被识别呢？后台一般来说默认的是callbak，我们创建的可是一个cbname，这里需要再一次进行替换，不使用forin，使用存在性判断就可以，只有一条属性，直接使用if判断就可以，if(default.jsonpcallback){cbname=default.jsonpcallback},这下，我们就实现了自己想要的名字的函数名，可以进行下一步的操作了，接下来就是我们的重头戏，函数的回调，封装的函数体知只是一个桥梁的作用，在回调的时候，既可以使用原生的js在页面中使用直接量来回调success这个属性后面的函数，也可以在这个桥梁的.success后面加上这个函数，不管是哪个，最后的结果都是在调用后台的数据结果，window[cbName]=function(data){defaults.success(data);}我们的dataType的属性值去设置的时候有什么规律可循呢？首先在后台传过来的是一个json的字符串，我们使用json，如果只是字串使用text就ok，如果是使用了跨域，格式就是jsonp，这里有个小疑问，就是为什么我们使用window[cbname]这样的方式，原因是在回调回来的函数会有有限在全局使用查找，如果我们的这个属性名是在我们封装的这个函数体内部，那么会找不到，这样的方式就是把它的级别提高到了window.onload这个等级，就可以识别，否则会遇到识别不了？保留疑问，在这里我们得到了bcname=jQuery12312312312312321_43213123123(23123);这样的形式了，最后，就是我们的收尾工作了，使用--创建一个script--设置script.src这个属性的值，这里我们使用的字符串与遍量的拼接，+''+使用在变量都为字符串的时候，遇到一些分隔符作用的符号，就单独的使用+'?'+或者+'&'+这样的形式来实现，最后，把创建的script添加到head。appendchildren（script）；在我们使用的格式中dataTYpe有6种。那么，不一样的datatype有什么样的不同点呢？就目前来讲使用什么样的datatype，在success中的函数调用出来的结果就是什么样的额格式，格式不一样，使用的拼接，或者剔除都是不一样的处理语句。

2.当我们使用ajax的原生js的时候核心就是xhr，那么都有哪些常用的方法可以被我们一直使用，还有就是在我们使用表单的时候文件的传输与其他的文字的传输有点不同，只可以使用post传输？还有就是函数方法也属性需要在webstorm中查看他们的参数与返回值，这样的查询最好就是实验，在sublim如何去查看原文件库的方法的简绍呢？sublim可以看做是做项目的一个轻量级的ide但是对于难以咯街或者是需要进行分析的代码，最好在webstorm中使用，这样就可以查看库中的方法与对象的属性与返回值，就像是九连环，很多属性的原理就是在基本的库中实现的，如果去追查，就要找到物质的构成这个环节，所以，使用定势思维去记忆基础的原理就可以，当然我们需要追寻到最深处发现没有下文的事就就应该在此停止。
3.七天的课程发现的问题就是，老师的教学方法与学生的学习效果的作用成指数曲线的效果，最大感想就是小样的额教学与王老师的教学的不通化之处，在与课堂的积极性与思路的活跃性，有句话这样讲，郝刚用在刀刃上，王老师的方法是知识量很大，不断的在巩固旧的知识。怎么去寻找这个平衡点呢？最好的方法及就是--------在积极性快要下降的时候，去补充这前五分钟的知识，或者是没有理解的东西，回过神的时候，就开始挺新的内容。

3.什么是数据库？exsel本来也是储存数据的但是由于可使用大小限制，还有安全性，导致我们必须要使用更加优秀的数据库，就像仓库一样，使用账号与密码才可以使用数据库，数据库中存储的用户关系与用户私人数据，不断的更新与备份，及时的数据更新，数据库的重特性就是数据无法转移的情况出现，会对数据的有效性负责，直接回到之前的交易状态，返回数据原始值。数据库本身的特性决定了数据库的重要性，数据库分类，全城是数据库管理系统，不单单是数据的储存，还有数据的保护。SQLServer属于微软。Oracle商业性，未来不太还，安全性不太好。Mysql数据库被收购，有很多的开源版本，还有新型的数据库，是一种关系型的数据库，分为行与列的数据库的特点，非关系型的数据库知识键值对的数据，没有数据与数据的联系与交叉关系。
4.25回顾与复习==============================================================
1.mysql的常用的指令，navcat会用就行。
2.模板的使用让我们懂得，你永远不会猜到框架你的方法对方是怎么写的。按规则来就行，这就是为什么有些拗口的框架是不可以实现长久的生存的。
3.formData的三种形式。分别是文件名，文件，临时存储的路径，这三个属性名，需要注意点。
4.使用静态的html页面，指向php，php编译语句检索mysql中的数据，最后输出到静态页面中。
4.26ajax04==================================================================
1.每日一碗毒鸡汤：前端的饱和，导致中高端的人才可以拿到高薪，就是计算机原理与php。
2.所有的文件都要使用问价命名，对于引擎的友好，路径文件不可以使用中文，这就是轮英文的重要性。
3.在php、中有一个属性是sleep就是休眠函数。
4.文件上传，后期使用的是jq插件，目前使用底层的js实现，原理是在事件委托中创建一个ajax函数，使用ajax的请求setxmlhttpresqust，在对比数据的时候，必须设置请求头，在使用formdata时，不可以使用这个请求头，为什么，是因为会有undefined，在不使用new Dataform时，表单的获取是声明额，ement，使用formdata是可以直接在这个实例上添加属性的。
5.所有的代码编辑都离不开数据，所以流程就是，先获取或者创建，其次进行操作，比如在获取了HTML中的文件名字，在php中还要使用三条函数，分别得到一个文件名，问价路径要设置，还有一个多次传输的添加time（）的函数，这样就可以多次的传输，但是不会产生名字重复与冲突的问具体。在用于使用，上传成功与失败需呀给用户提示，就可以使用进度条的方式，在htnl中嵌入一个div》p，为一个白色的长条边框，在上传的时候可使用得到的文件大小与总的文件大小，怎么样才知道传输了多少额？在jq中有个时间，是onprogress这样的函数，就可以显示上产的进度。不写也可以，就像邮箱的进度条一样，最好写，这个事假跟onclick一样，是一个事件对象，有两个属性，一个是(e.load/e.total)*100+'%',其次字开始获取元素p，设置它的宽度是灵活的，这里使用它的宽度是百分比的样式，在样式中width的宽度%值的是相对于父级的宽度。
6.使用一个空数组来存储非空的数组，在循环中按条存储，为什么在php语法中，连接数据库的时候，$arr='select * from user',$result=mysql_query($arr),使用myaql_fetch_assoc($aresult)，这样的方式，得到的是一行数据，在while循环中使用但是不需要使用累加，使用array_push(原函数，倍加的函数)直接输出就可以了，这样的到的还是不一样的数据。需要注意的是，在php中很对的方法就是内置的，不要我们去自行修改，在编码阿德过程中，需要注意的是，函数的记忆李参数的选择，返回值的类型，使用返回的值的转化，最后才是字符的使用在静态的页面。

7.开始制作ajax的案例，盆友圈的下拉刷新，上托加载更多，功能的实现就是在论坛中创建动态，首先是创建一个固定的style，绑定一个js事假，后台需要一个传输sql的接口，就是使用后端语言，比如php，创建一个可以输出数据的json_endode的格式，这个格式传给js，js可以把这个数据使用解码decode，使用原生的str累加，或者是creat的方式都可以添加到页面中，需要注意的是，页面的样式的宽高设置，应该height不是固定的，还要用到粘性底部的东西！！！！

8.前端渲染，使用静态页面渲染在前端创建js与html，还有一种是后端渲染，在后端就可以使用马两种方式就创建标签跟动态创建的方法。

9。前端的功能一方面是验证性，另一方面是就是增加改变查询删除，使用前端的页面尤其是在管理员页面的时候，以一个网游为例：游戏的等级与装备的数据是可以实时更新的，这里用到过游戏心理学，装备的数据就是可以实时跟新，装备的掉落，为增加，卖出为删除，强化为修改，图鉴为查询，再经过后台的模型绑定与设计，就可以实现游戏的可操作化界面，所以说，那句话，编程界，最重要的是数据而不是代码。在我们制作之前需要有一个清晰的思路，这个思路就是我们要先干什么，比如，先把我们的html，js，css构建好了，这个时候要注意的是自适应的结构是最棒的，第二个是准备好我们的数据库，数据库的内容的接口，使用php来编写，就是离不开增删改查了。1.考虑到jq，考虑到ajax，考虑到跨域就要用jsonp，2.思路方面，使用什么风格的界面布局，使用什么什么颜色，使用什么每个页面要实现神马样的功能，页面的相互的跳转，。接下来---时详细的步骤，首先，建立文件，html，css，js，php，数据库，------------其次，编写html文件的标签，先临时填充，这些数据不是业务数据，业务数据就是后端传过来的文件跟数据，这样页面编写借宿，----------接下来编写一个php文件，使用获取数据库---显示数据的内容---编译一次显示为正常的格式---c+s+s---右键格式化----------再次，创建js文件，使用jq的方法一函数，初始化数据列表，封装一个自己使用的jqajax的代码函数，$.ajaxde success:function(){};这个函数里面就是模板，写完之后在html页面中使用模板，在一个<script type=text/html ><script>这样的额一个标签中，建立模板，建立瓣膜的方式就是该语法，没有太多，就类似于markdown这样的格式，需要多加使用，这里会遇到的几个问题，就是当我们建好了模板，但是没有数据穿过来。先看js文件中的地址是怎么操作数据库的，记住，在success后面的函数中要记得写上可以在htnk中添加数据的语句。我们在写页面的是时候，可以先写一个尖的数据页面，之后引入php的时候，再把我们的数据去注释掉，还有注意一点就是，代码执行的顺序性，还有就是包含性，函数声明后一定要调用才行，调用的时候，也要注意是不是可以使用在这个位置，跟多时候，我们会遇到的问题就是局部作用域的函数，或者获取的数值，一般请款下，不变的数据，直接在全局获取就可以，但是对于动态的数据，需要使用函数内动态的获取，，另外，函数的回调，在一个函数内把另一个函数作为参数，或者有时候，函数的嵌套也会遇到无法访问外部作用域的数值。典型的问题就是函数预解析，变量提升。对于php页面，就是在编写一个接口，接口的编写需要自己会写，原理就是在php页面中使用一个str的字符串数据，把这个字符串，使用query的按个语句去编码，这样返回到success这个，键值对中的函数中，在这里使用模板，可以添加数据。适应最多的还是jq的使用，方法的使用，参数的全部使用，与返回值。可以这么说，所有的祸胎返回的数据，都要遭success这个函数下去处理数据，这样的话，success的权重真的好高啊。在实现一个案例的时候，会不由自主的使用到所有的案例，这就是蝴蝶效应，或者是难以预料的错误与心得方法，类似于总结与心得学习，总会有出乎意料的事情发生，要习惯去修改不不完美，而不是去删除重建，说白了就是不要逃避，工作学习乃至生活都是如此。有一个小窍门，使用机器语言，逻辑关系很重要，在点击添加的时候，点击一次，当我们下次再点击的时候，会执行上一次的点击一次，或者是修改时候，这样就要使用县解绑，类似于这样的使用方法这之前也有很多，在使用一个特有的书信的时候后，先要不其他的额刷一遍。在去修改当下的活动事件。字符串的拼接与米板的使用，与动态页面的创建都是可以使用类似“形参”这样的思想，先写一个我们会用到的格式，然后注释掉。

10.更新一个数据库的语句：update username set name='".$valeu."',age=''

4.27ajax05==================================================================
1.mysql_query()后面的语句使用改查是字符集，使用增删是布尔值。
2.后台的两个数据库使用同一个表名怎么办？
3.后台获取数据的时候，根据数据的内容不同，使用$_POST[]得到的变量的类型是不同的，如果是数组类型需要使用转换为string。
4.代码的优雅值的是什么？代码的优雅的就是，代码的结构整体清晰，分块编程，逻辑结构整齐，注释明确，可以自我保护，不去干扰别的区域的代码，可以维护。针对的是后期的维护，扩展，可读，诸如此类···。
5.id的不清空是的id的值一直在增加，可以使用val在顶部执行是
6.一个按钮，在不一样的功能中使用这一个按钮，但是，直接使用两个按钮就可以吗？如果对于一个click事件要绑定两个函数的话，就要使用unbind（click）.click(),这是一个解绑其他，绑定自己的方法。
7.去往后台的表单数据有时候会出现undefined，从表单是否有值，传递的type，后台的接口路径，语法正确性，去分析。验证性判断的工作属于前端，一方面是使用正则判断输入的格式是否正确，另一方面是使用isset（）这个三元操作符，来补全一个undefined。
8.一个很简单但是有很容易犯错的细节，1.采用异步的方式，在事件队列的三个类型，全局中直接运行的语句是得不到事件函数内部的数据的。同样的解释方法：2。DOM元素的操作，必须在页面渲染，也就是页面有才能去获取，否则就是报错，哈哈，（来自同学的问题）
9.网站的开发流程的开发模式：后端渲染与前端渲染--都会生成一个完整的静态页面，最直接的区别，在network中，后台请求如果是也整个页面，那就是后端渲染。包括模板在内的html骨架为支持，只从后台请求数据去填充骨架就是前端渲染的开发模式，php的两个渲染方法，一种是在多个php中间写html，另一种就是在一个php中间写html，之前讲到api，应用程序编程接口---这里有出现了一个接口的定义，是指url，接口就是向后台请求，前端要有参数，使用url带过去，或者post传递，后端根据检索合格，就可以实现准确的对接交互，这就是对接口的简单的理解。
10.接到需求--业务需求---界面展示---观察使用前端还是后端渲染---一拨人后台接口--一拨人前端渲染---一个团队---协商方案异步进行---微数据前端制作后期注释掉---后端根据需求制作接口---多个文件比如http://xxx.com/xx/a1.php,a2.php,s3.sql---每个接口都有文档去注释我们的接口是是什么使用方式，什么作用---文档包括了接口地址，接口参数，接口返回值（这里有一个很多标准文档）---前端根据文档去实现业务功能（增删改查或者是局部刷新）。
11.一个前端的开发文件夹应该是什么样的？一个语义化的文件夹还是英文的命名如果没有请使用demo--里面有下级文件index.html，libs,css,js.api.开发的流程---一我的图书管理平台为例---总的思路就是调用接口》获取后台数据》渲染局部页面（模板）---查询图书功能函数---
在制作过程，最核心的是js的编写：还是老套路，获取接口，使用，处理，在内部，创建命名函数--下边调用--在明明函数内部又是success的获取data，创建模板或者判断flag，渲染！！！--当项目进行到这个时候就是一大堆的bug，这个时候就要用到理论的支持（比如：事件绑定的冲突--绑定事件2先解绑事件1后绑定-------路径的正确性-表准的文件对接------变量提升，沙箱抗干扰，预解析，异步的全局变量赋值异步函数内的值失败，参数格式，返回值格式，对象的变量属性替换，动态的val放在函数内部才行）。
12.想起一个文题，使用一个函数使一个dom进行了改变，想要使用另一个函数使第一个哈数停下来，怎么办，使用stop可以，使用今天的绑定也可以，但是，使用递归的函数，还没办法停止。
13.使用json的type，在success中参数data是对象，积极式获得的数据是对象的形式呈现，需要去解码，因为是对象，就可以是用点出的方法去一一声明，并去使用val（）的方式去改变内容。前端的形势更趋向于后端了。目前的任务重在理解，高度不够，写出来的代码就是垃圾。
14.$.extend(true,obj,obj1)---可以进行对象的覆盖，如果第一个参数是对象，第二个乃至多个后续对象都会在第一个对象上覆盖，--原理是递归的拷贝，深拷贝=多层拷贝，浅拷贝的原理就是值拷贝一层属性，第二维的对象属性值不可以覆盖。extend-----param(null,true)，使用true就是深拷贝，使用的价值就是jq插件的使用。怎么使用到这个extend的覆盖？还有一个重点就是each(obj,callback);
15.插件的介绍：全局插件，实例插件--全局插件是系统性的插件，有庞大的语法结构，使用顶级的队形jQuery在（$）.出来的函数，全局插件使用extend这个函数，里面是键值对的函数集合，包括了多个函数想要同时全局声明的插件。当然，使用$.foo=function也可以，但是最好不要这样。实例插件也有自己的规则，一个是选择器的那种，得到的而是全局下的实例，跟全局下的函数使一个级别，可以实现原型链的prototype的指向，也就是到不属于自己的一个函数。这个怎么使用？在使用非演示的实际情景中怎么去用？？？以案例tab栏目实现：从底层开始写，首先创建静态HTML骨架，div包含三个input，三个二级div，style样式----低级代码开始：使用DOM，获取所有的元素，为所有的第一个使用样式。----开始制作this样式，for循环给所有注册事件，清除所有的样式，this所属样式改变，获取索引的方式index=[this.index],下面的div对应的索引开始改变样式，ok，table结束，好吧，这其实是垃圾代码。====--=-=-======优雅第一步的代码：在局部封装的函数内部，尽量的使用变量自我所属，使用外部调用，封装函数可以传递参数，为id。========----=======问题是单个方法的业务逻辑太多，外部显示太多，这是先做什么后做什么，与此相对的就是面向对象，原理：先配置构造函数，描述了功能的属性方法，属性，也就是获取标签元素就是属性的使用，放在构造函数中，下面创建实例函数，把这个函数作为一种方法，这样的代码就可以作为js模板。这里需呀注意一点：在使用tab的代码中，原生的代码就是使用这样的创建构造--实例函数的创建--调用整体----最终的优点就是可以重复利用，利用，利用。这里的利用有三层意思，一层意思是使用骨架中的script标签调用，二层意思是在封装中构造函数的属性可以在实例函数中使用作为一级对象，或者是this下一级对象，要摸清原型链的使用，说道底，原生js写的好不好就是原型链掌握的怎么样。=======----========，在工作中，除了jq无法实现的情况需要自己去写js封装，更多的是使用jQuery去写，首先开始初始化，不同于DOM，jq要把要用到的变量使用一次var声明，使用逗号隔开，都为null。接下来是最神奇的地方，在jq函数中，使用$("#"+id).find('input:eq(0)').css```````;频繁使用的词语，业务需求，代码优雅，阅读性，封装函数可定制。使用一个extend就可以价格参数为对象，默认属性为对象，替换后，就可以实现一个函数实现同页面下的不同的效果。当我们使用封装的时候，样式，事件，甚至函数都可以被改变，1.这里使用了bind，on两个方式绑定事件，遇到什么情况就要解绑2.使用extend使用true的时候，可以实现深拷贝，在js传参数的时候，多层对象也可以实现覆盖。3.关于在后端的延时sleep（）个前端的setTimeOut函数的使用。数值的单位后端php是秒，前端的单位是毫秒。
16，canvos，js进阶面试用的多，jq的底层原理，之后是h5，c3，项目的模块化。
5.4js高级=====================------===================================
1.编程语言是怎么来的？就像英语一样，是由语法与单词组成，使用这样的语法就可以以人来操纵机器，实现它的原理，是机器语言，他的特点就是没变通性，只能按照ecma的标砖来执行语句，js的操作的内容就是对象，灭有对象，所有的程序就是没有意义的，对象的含义，就是摸个事物，这个事物还有属性与方法，在构造函数中，也是有属性与方法，但是构造函数函数中，使用的是赋值，都是抽象的，没有具体的属性值，只有属性名，与之相对的是实例化对象，具有具体的值cm，kg等，在构造函数中一般使用的方法是，使用this，后面加上this的属性与方法，这是一种抽象的模板（构造函数不要忘了使用形参），实例的对象就是具体的使用了实参的构造函数。
2.对象的来龙去脉：对象有构造函数开始，一般情况，我们说的对象就是实例对象，吧构造函数实例化才有意义，一种是使用字面量的方式使用花括号的方式，另一种是直接去new，原理层面：在堆内存中存储的是属性方法与属性中的数组与方法中的函数，在实例化中只是一个变量名与地址。那么为什么构造函数可以与实力对象可以建立联系呢？首先就是在构造函数中，默认的teturn是this，那么在和实力话的时候范湖的就够也就是我们可以看到的就是实例化的参数，this，但是但我们使用一个自定义的基本类型的时候就发现，没有作用，返回的还是this，但是一个函数只有一个return，但是因为构造函数只返回对象类型，基本类型会被忽略，重点来了，当我们使用rerurn一个对象的时候，就返回了这个return的对象，所以这种情况少见，只有一些框架的时候会用到。
3.那么对象怎么去创建呢？字面量+构造函数+工厂模式：一种方式是使用构造函数，变量名必须是首字母大写，内部使用this（这样使用的作用就是代码的重用），在外部使用new来调用或者说是创建并且去传参。另一种使用字面量，可以使用直接在对象的括号内部使用键值对，或者先申明一个空的对象，在对象的下面去赋值对象的属性。最后一种是工厂模式：其实就是构造函数的原理，先声明一个普通的函数，在函数内部使用形参，形参的值可以赋值给内部变量对象，最后返回这个对象，在外部去调用的时候后，直接使用传参，不需要使用new。【这里有两个小疑问：一个是：当我们使用一个字面量的方式器构造一个函数的时候，他的构造函数就是object，可以从函数的proto中去寻找，顶级的时候就是null；第二个是我们见到的DOM中使用的获取元素，甚至是创建一个元素document.getElementById("xx"),这样的函数，他指向的构造函数是DivHTML这样】，还有一种对象的创建是使用外部的腻子脚本，这就跟jQuery的使用方法一样。所有的函数都有原型，与都有构造函数，重点是所有的对象都是函数，那么，就是说，所有的对象那都是具有构造哈数的。
4.所有的API都是一个封装好的接口，包括一个临时性的封装函数也是这样的，那么这就是为什么我们常使用api，他是去除重复，节省空间的作用，但是有没有更好的节省空间的方法呢？在面向对象的编程的时候，就可以进一步去节省空间。使用原型链的用到的额是prototype与proto这两个，这两个的指向本身是没有差别的，区别在于所属的类型不一样，但是指向的都是自己上一级，也就是来自的地方，这样解释很模糊，但是索性有个constractor可以查看是从哪里导出来的。
5.验证了一个无意义的函数的证明，就是使用hasownPrototype这属性一in属性来判断是不是在函数中存在摸个属性，当属性名不同的时候，使用一个&&的判断是可以实现的，但是当两个构造与原型都有这个属性的时候，就是最近的原则，明确一个额问题，当去验证一个问题的时候，理论的解决可以的话，就不要使用逻辑的角度去解决。
6.什么是原型链？
当实例对象需要使用一个属性或者方法的时候，本质就是对构造函数的调用，现在构造函数中去寻找，现在起点去寻找，找不到后去上层函数中去寻找，一次类推，直到查询的Object.prototype中去找，到这里还没有，就不早去寻找。一个实例化函数是谁做出来的它的原型就指向谁，只不过是显示的方式不一样的而已。
7.在使用原型函数的时候，需要参数但是在原型函数的括号内不需要形参，在构造函数中的参数就可以直接在原型函数中时候用。
8.清除浮动伪元素：content,clear:both;
9.使用原型的函数表达式中：this指向的是构造哈数的实例化对象，如果在函数内层还有函数，这个函数的this，不收到外层的影响，该是谁还是谁，这样就不可以使用this，需要在最近的地方，也就是this最后一次改变的时候去设置this的缓存。
10，在setInterval这个定时器的时候，第一个参数需是一个函数体，不可以是一个调用，调用时在别的地方执行这个函数体，最后返回给这个参数一个返回值，这样就得不到定时器的效果，还有一个是setTimeout用来延时执行一个代码，同样也不可以使用调用返回值，只可以使用调用函数体。使用一个超时调用settimeout的模拟间歇性调用可以实现的功能，是最佳的方式，因为在内磁执行后就会停止，不设置新的调用就会停止，但是使用间歇调用就会出现一次结束后在还会多执行一次的现像。
5.5js高级02===================================================
1.风萧萧兮易水寒，壮士一去兮不复还！！！
2.今天主要讲的是函数的一系列的问题，比如如何生产一个函数，函数有什么用，最为对象，与作为方法，都有什么用？函数怎么去调用，调用的方法不一样产生的结果也不一样，注意的是，不管在那个函数中，时钟都是有this，在window'下的函数，就是bom对象，在bom对象下，所有的this的都是指向了window，当我们使用字面量的方式创建了一个函数，这个杉树内部有了一个函数，呢么这个函数的this就指向想了最近的创建他的对象，就算这个函数是他的其中一个方法的函数，this指向的也是对象，而不是这个方法。使用构造函数的时候，this指向的就是这个构造函数在实例化的时候的对象。使用时间函数的时候，this的指向就是这个电机的对象或者元素，一般在DOM元素中才会使用到事件函数，还有一个是延时调用的函数settimeout与setinterval这两个函数，this的指向就是window，还有直接使用，总之，只要前面没有前缀，就是window。这里就要使用that这个方法阿狸缓存this的数据，当使用玩一个函数的this之后，在下一个函数，或者是内层函数也要使用this这个属性，这时，使用this是不合法的，因为this的指向已经改变了，但是不使用this，直接使用变量或者实参不太好操作，就可以把this赋值给that，使用that去操作别的函数中的对象与方法。
3,补充一个知识：单线程与多线程的区别。
首先是进程与线程的关系，当一个程序开始运行的时候就是一个进程，一个进程可以被多个线程同时执行。也可以是单个线程去执行，根据任务的复杂程度与耗时程度，拥堵程度选择最佳的方式，使用同步也就是单线程，按照顺序依次执行，前面的额拥堵后面的不执行，会遇到无法响应的问题，多线程用来处理cpu闲置，多个线程同时执行一个程序的不同任务，缺点是在耗时短的时候，浪费cpu与资源。就是合适的情况选择合适的线程。
4.this的指向：在双层对象中第二层的对象下有一个方法那么，在这个函数中的this指向的方法的调用者。而不是顶级对象。
5.7js高级03====================================================
2.使用jQuery使用fn代替类似于js原生中的prototype。                    
3.案例作业怎么做，两次点击的时间怎么去处理，我的想法是制作解绑，再次绑定。逻辑思路是怎么做的？按照编号与各个属性来排列整个面板，可以想象，需要缓存this，函数的操作对象会改变，在细节方面，1.得到了一个可以在console，log出来的数据，就可以适应innrhtml，document.write.老师使用的方法是首先在排序函数中传入一个参数，2.这个参数是一个正负1的变量，在上部for循环遍历th注册事件中使用了在点击的时候就使用flagthis.flag这个使用方法，点击第二次的时候，使用新值变成旧值的取反，这样使用变量的方式，就是布尔值的妙用。具体的难点在于，这个正负值影响的是内部函数的取值的正逆序，贯穿全局的一个变量，是怎么清晰的使用的，不管做什么样的代码，首先在大脑中有一个清晰的逻辑结构还要有一个清晰的函数链接树状图。为什么一个总监写的代码程序员是看不懂的，不是代码语法的问题，问题在于那条链的完整，在写代码之前就应该想到整个布局是怎么分布的。写代码的时候就可以有的放矢。
4.在复杂的返回的数据的处理，还是等同于最简单的console、
5.冒号前边的是协议，就算本地的一个文件夹也是一个协议。同域与通源是协议端口域名。为什么在跨域的时候，可以看到请求，也可以看到数据，但是页面没有去渲染，也会报错，原因是浏览器的阻拦。
6.使用error：function（e）可以事件什么功能。
7.在使用ajax时候后，实现数据的交换，前端任务是获取后台，或者跨域请求的获取，正真的数据的是后台说了话。为什么success后的函数但会的data的数据是对象Object？这里的字符串与对象的相互装换的方法------------------------、这里补充。
8.学习路线：理解（使用拆解的方法，以等于号，冒号，分号为界限分割再次找到变量与值，键值对，调用）--练习（准确地临摹，亲自写一遍）--掌握（做笔记，找共性）--使用（查询，找bug）。
9.最后一个共性，关联数组与标准数组的形式一样，当使用[]的时候就是相当于使用来看点号，只是有时候不可使用点号。
10.我们知道对象可以使用点号的方式，那么函数的调用也使用点号的调用的话，是为什么。首先使用call，applybind这样的方式去调用函数，这三个属性是属于Function，但是所有的函数都是在window下的Function的实例对象，在Function.prototype.call是存在的，所以在普通的函数是可以调用这个属性的。在js的整个体系中，只要是函数买就是FUnction的实例对象，包括了Object，Array，Function，function。
11.一个整体的很大的库--jQuery的源代码---浏览器控制台的window下的所有的子类。
12.函数有三个角色，普通--有——proto——，构造--prototype，对象--有个可以点的出来的属性.
13.使用原型与继承可以省一些代码，子级的实例调用，会直接从父级的函数原型对象中抽取需要的属性，但是原型的继承有自己的缺点，1.父级的构造属性会交给自己的构造，这个无法避免。2.第一次使用实例，不可以随意传参。
14.原型链与函数链不一样，不一样的地方在包括的起点不一样。
15.==借用构造函数==与原型继承会解决上面的bug，是什么？可以在自己构造函数中使用改变参数的方式，但是得不到原来的原型链上的属性，原理是使用call改变指向，把使用的参数设置为上一级的对象，使用方法就是使用call的方式把需要的地方去改变。父级的覆盖，最核心的是解决了原型继承的覆盖与污染的缺点，但是产生了无法继承父级构造函数的原型继承成员。
16.==组合继承==what？原型继承与借用继承的组合，就是既可以实现整个原型链的属性的继承，又可以选择性的实现构造函数内部的参数的传参，灵活性很高。why？原型的继承会在所有的原型链上就近寻找，使用call的方法可以改变指向，就可以在一个新的构造函数中传入一个其他级别的构造函数的参数，或者吧这个参数传到别的构造函数中。
17.创建一个对象的方式有很多，一种是字面量，一种是newObject，还有一种是es5新特性下的Object.creat(),这里真正的空对象应该是连--proto--也没有，就是用creat（），注意的一点，必须传参数，可以使事前申明的对象，或者是null这个对象。
18.当一个属性的复制，就是拷贝，会被覆盖，在jquery中使用深拷贝与复制原理就是fforin循环，抽取属性与值，逐次的赋值给下方的对象，有就替换，没有就新法人赋值。
19.在jQuery中创建一个键值对的对象extend（内部是对象），就可以在顶级这的地方设置一个属性。
20.右键的事件oncontextmenu--函数内使用（return··false或者window.event?e）在addEventListener绑定事件中不可以使用return··false；或者在on系列下，是无法使用冒泡的。就是说，区域实现了，但是想用冒泡是无法实现的。
21.事件捕获与冒泡：
事件传播——冒泡与捕获编辑
默认情况下，事件使用冒泡事件流，不使用捕获事件流。然而，在Firefox和Safari里，你可以显式的指定使用捕获事件流，方法是在注册事件时传入useCapture参数，将这个参数设为true。
冒泡事件流编辑
当事件在某一DOM元素被触发时，例如用户在客户名字节点上点击鼠标，事件将跟随着该节点，继承各自的父节点冒泡穿过整个的DOM节点层次，直到它遇到依附有该事件类型处理器的节点，此时，该事件是onclick事件。在冒泡过程中的任何时候都可以终止事件的冒泡，在遵从W3C标准的浏览器里可以通过调用事件对象上的stopPropagation()方法，在InternetExplorer里可以通过设置事件对象的cancelBubble属性为true。如果不停止事件的传播，事件将一直通过DOM冒泡直至到达文档根。
捕获事件流编辑
事件的处理将从DOM层次的根开始，而不是从触发事件的目标元素开始，事件被从目标元素的所有祖先元素依次往下传递。在这个过程中，事件会被从文档根到事件目标元素之间各个继承派生的元素所捕获，如果事件监听器在被注册时设置了useCapture属性为true,那么它们可以被分派给这期间的任何元素以对事件做出处理；否则，事件会被接着传递给派生元素路径上的下一元素，直至目标元素。事件到达目标元素后，它会接着通过DOM节点再进行冒泡。
22.什么情况下使用预先判断？遇到分支情形，需要使用判断，就像电路的走向一样，考虑到当程序走到这里，或者当其他的地方再次调用这里的代码时候，会有怎么样的流程与执行步骤，遇到了情况请记下来，想象流程的时候请使用电流的流通原则。
5.8js高级04====================================================
1.一个被构造出来的函数，只可以获得原型上的属性与方法，获取不到上一级的本身的属性与方法。
2.一哥系统自带的额基本包装类型，原型的构造器是Function，在Function内部的--proto--与prototype指向同一块区域，内容完全一直，这是一个特例。
3.有难度的制作网页：一个是使用原型于继承制作，其次是使用动态createElemnt----tag字符串----添加到某个标签元素中--最后，最重要的是----所有的动态创建之前都要考虑到存在性判断（有就不再添加），与复合型判断（数据为空就不再添加）。
4.this的作用，this就是一个对象的代替，只是这个对象的属性与方法是可变的，一方面使用在构造函数，方面调用传参灵活，获取不同的调用结果，另一方面就是在原型中使用还是代替构造函数，this在遇到下一个函数是会改变，但是在塔器函数内部使用对象名来使用所属的方法，两种方案，一个是直接使用对象名，另一种就是缓存this为一个其他的变量；总结一个用就是只要在一个函数中使用顶级对象，就优先考虑要不要使用this。
5.程序的运行，执行规则，首先是顺序流，优先执行的是输出语句，遇到后就执行，赋值语句会一直执行，直到赋值为最后的语句，这样就出现了变量提升。函数的调用有很多方式，有一种是事件函数的自调用。
5.9js高级05====================================================
1.today is last day of js。笔记先使用笔记本来记录一个草稿本，有时间的情况下在去补充一个完整的笔记。编程的过程会遇到的两个问题，一个是代码的语句理解层面，另一个是思路理解层面。
2.JavaScript中为什么会出现undefined的不正常现象？是因为程序的执行一方面是从上带下的顺序一方面又是从左到右，在递归中语句执行的顺序在递归的else（）内部是按照自身函数调用优先执行，就是会出现这样的一个情况就是--开始---开始----结束---结束----结尾，这是因为在slse内部使用自身函数的调用的话，就不会执行调用下方的语句。这就是优先调用。类似于一个函数的执行没有结束期间发生再次延续的效果那么，之后的还有一个执行过程将会被无限期的延后，只要不是遇到事件队列，就会一直这样执行下去。还有一个不一样的就是运算符号的优先级。在所有的符号中，优先级比较高的就是（.-----!-----~）这三个可以使用赋值与分支判断语句。还有一点就是预解析，包括了全局变量与函数声明提升。函数的声明是优先的全局输出函数体，局部作用域也是函数声明优先执行，依然是函数体。就算传了参数也是一样。额外还增加了一个事件队列，就是全局执行结束，触发那个执行那个，没有触发器，就按顺序执行。这个会发生类似于变量提升的undefined，延时调用，on下的所有事件。
3.布尔值：什么情况下是true，什么情况下是false，一个是非空的，另一个是真空的。那么补充知识点就是0，“ ”，undefined，null，一个例外，[]就是true。其他的所有的有值就是好的。
4.讲到了作用域链，这个作用域的效果就是。如果掌握不了太高深的语法，就是看书，总结知识，编译代码获得自己的想法，总结博客，还是老生常谈的问题，在有限的时间内尽量多的去记录笔记包括老师的知识与方法论，还有经验这个，查歌手的时候不停，想要的时候就没有。
5.作用域链：在全局乃至局部作用域，同级的两个函数内部不可以访问到同级的函数内部，就是函数的保护特性。
6.不管在怎么样的函数，在执行顺序上优先函数，其次变量声明，最后输出---这样的格式，预解析包括变量提升与声明提升（声明提升指的是覆盖同名的变量声明）。
7.闭包的条件，函数的嵌套形成了环境，就是内层函数本身所处的作用域，外层函数包裹的空间成为作用域，内层函数就处于外层的作用域中，就是所有的函数都是闭包咯？？
8.闭包的作用：一个是个保护的空间，另一个是延长了变量的生命周期（因为在正常情况下，函数被调用之后就把函数内部的变量释放，外部不可以第二次访问到这个变量），为什么是闭包不是普通函数，唯一的区别就是调用后会不会被释放，一个闭包的环境下，内部的函数可以被多次调用返回值，并且内部
的值依旧可以被使用，如果返回值是处理内部变量的，那么，每次都是新的值被处理的，｛缓存作用｝。
why？出了之前的布尔值的使用，这里使用的是return ，之前见到过，使用return与不使return的区别就在于
9.一个作用域链与return闭包的结合，来解释for输出三个3与输出三个123，这个案例。
10.使用闭包来实现缓存是它的核心所在，是因为闭包使用了return ，就会把返回值分别存储，这也是为什么一般人用不了闭包，在代码冗长的情况下使用闭包，在上一个案例之下，在dom中使用闭包可以分类获取索引这样的功能，就不会出现每次都执行完循环周，i的值一直在随动，取得是最后的那个值。---从原理的层面来讲，闭包开辟新的空间，这样就导致在闭包内部，变量不像之前那样，是相互独立的。但是在本空间是缓存的。但是可以进项又换，原理与闭包一致，就是缓存一个值到需要的函数中。
11.尝试制作一个案例，使用for循环，递归，闭包，自定义属性setAttribute。
12.闭包的构建流程，首先创建一个return +变量。或者使用函数也行。
13.非数组调用数组的方法，使用call。apply后面是两个参数，前面是空数组点出来一个自带方法。
14.使用apply的作用是调用了改变this指向的函数，并且参数数组可以被剔除为一个一个的。详细的理解一下arguments这个变量？的使用方法。
15.为什么会有不一样的值？一个是在return的内部使用了变量的声明，每调用一次都会缓存东西进去，在return的外部指令只会在return前调用一次，相当于值会被保存，但是因为在函数外部相当于外层的return为内层函数，这样就形成了()()这样的格式。闭包闭包调用的是它的返回值，而且，返回值还是处理后的。但是在rerturn'的内部使用变量声明就不可以缓存了。
16.最后，闭包可以缓存，也消耗资源，使用它就是用到了更大的消耗的时候。比如，计算太复杂期间需要使用对此调用，要设立的函数空间多于闭包创建的空间数量的时候。
17.使用今天的代码来抽取知识点，---arguments这个函数只有在函数调用的时候才可以使用。
18.使用自己的理解来执行一串函数的过程，在一段代码开始，声明开头，其次开始使用开头调用的区域，这个区域就是用来调用所有的，调用的时候注意一点，使用了闭包，那么最后的结果就是调用一次，下一才使用上一次调用后的结果。
19.闭包结构：
//===================================================
function(){
    var cache={};
    return  function(){
          cache[''hello]='123';
      }
}
var foo=fn();
foo();
//===================================================
20.当一个函数内部的arguments想要作为另一个函数作用域内的参数，直接调用，会把整个对象传过去，使用apply才可以把对象拆分，实现多个参数一致。什么情况适合用什么样的方法，这就是api的使用。
21.关于单线程与多线程。结合事件队列理解的更深。
22.类数组转化为数组使用slice，不改变原数组，使用push可以创建数组，会销毁原数组。
23.关于事件的补充：事件代理，事件委托，核心就是使用冒泡与捕获，区别于for循环，节省资源的表现为，节省cpu，节省内存。
24.面试的时候，很多时候，不是要求你会，而是要求你见识过，要的是知识面比较广。
25.jquery中，this.value=$(this).val();
26.jquery对象的本质是类数组｛0：xx，1：vv｝。 
27.自定义事件，一个加上事件，一个
5.11canvas01=============================================
1.事件是浏览器也是js的核心，是一个观察者的设计模式，就是监听，但是一切动与不动都会被监听到事件。核心就是基于事件的。不管有没有设置事件函数，点击后会被监听。但是事件的核心又是冒泡。默认的事件永远是冒泡，不管有没有设置事件函数，点击一个子元素，所有的父级与父级以上的元素都会自动触发点击，有就运行函数体，没有就不触发，当有多个子元素触发事件，就会出现多次父级。这是避免，还有利用冒泡，设置某个子元素，设置某个父元素，这样点击两个事件同时触发，各自执行各自的函数体。或者直接在父级注册，子级的点击会冒泡，这是子级不需要设置函数，父级设置就可以了。（常见的事件：click<onclick,dbclick>----）
2.事件的体系：
2.0观察者模式与事件冒泡---浏览器的处理事件的核心----单线程的解释器。
2.1事件绑定：1，行内事件绑定，2，btn.onclick=function3，addEventLisenter（）/attachEvent（）
2.2事件解绑：
3.面向对象核心-----this。======浏览器事件----冒泡=====
4.使用清空：removeAttribute，或者=null，或者删除父节点的子节点。
5，canvas属于canvas，h5，包括h5，c3，canvas，还有新的api，是一整套的体系。英文释义为画布，它的功能呢个也是画布。
6.canvas最大的作用是制作动画的图表可以展示数据。table是制作静态的表格，div是用来大板块的布局。
7.使用canvas画图的步骤，1--准备画布--2--准备画笔--3--先描路径--4--填充路径
8.canvas标签的宽度与高度必须在html结构中设置而且不可以使用行内style。
9.1--获取画布--var cas=document.getElementById（"cas"）;
9.2--获取画笔--var ctx = cas.getContext("2d");//webg1;
9.3--描绘路径--ctx.moveTo(100,100);//画笔移动到这个指定的坐标==ctx.lineTo(200,100);//直线路径移动到摸个点
9.4--填充路径--stroke或者fill。
5.12canvas02=================================================
1.学编程完全靠自己的能力，经验是最重要的，这就是为什么刚开始工资很低，后期工资很高，学历对it行业的影响只影响起步阶段。
2.canvas的原理就是，使用两点一线的原理，创建lineTo，最后好似用closePath（）；
3.实现所有的实线，就是每次增加一个像素的点，在循环结构中，使用这样的语法，每次创建一个新的路劲，新的路劲下新的起点，新的lineto，新的strokeStyle，都是新的，总之就是每一个点就要是独立的新路径。这样使用y与x的函数关系式，
4.新路径没有的属性，会沿用原来的设置的属性，这样就出现了无法改变虚实线的问题，需要使用虚线setlineDash（[]）;
5.彩虹色的原理就是每一条闲的颜色在渐变。
6.使用绘制图标都可以使用面向对象的编程，游戏是个更倾向于过程，报表更侧重于封装对象，还有第三个移动端的手指操作。
7.目前互联网投资热潮下降，资金下降，人才饱和。
8.使用lineTo的作用议案使用来描述一个函数曲线，接下来使用独立的api可以实现具体模型绘制具体的模型，动画的原理就是反复的使用独立路径的绘画与清空，控制时间，达到模拟动画的效果。
9.绘制圆弧==============圆形曲线的一部分
9.一种是使用函数xy绘制标准圆，另一种是使用art（100，100，Math.PI*30,0,Math.PI*/2,true）,这里使用角度不是数字而是弧度PI，顺逆时针得到的曲线是不一样的。
10.map方法的做用就是把数组中的每一项数组改变生成新的数组。
11.有四个方法路径是独立的不需要使用绘制路劲的方法。
----------strokeRect-------fillRect-------strokeText-------fillStroke-------这四种不需要使用fill与stroke，其实想想也能型明白了，方法名中就已经有了。
12.ctx.font( 大小 字体)；
13.默认情况下，默认的坐标可以改变，
14.canvas设置文字的属性：1.水平对齐方式，left，center，right===2.垂直对齐方式，top，bottom，middle，3.文字的开头方向（属于css3的属性）。
15.使用这些属性，可以实现九宫格的案例，代码补充在这里。
16.最早的浏览器是网景公司，被微软竞争被整垮，手段就是计算机图形界面。
17.制作饼图hi哟几个注意的技术点：首先是创建构造函数，构造函数需要添加初始的数据，其次，创建功能函数，在入口函数分别一一调用，然后，获取可以操作的数据，重点在数据的操作是怎么处理的。---处理的方法是：先抽取数据，数字进行等比例计算，获得弧度角，在for循环依次获得饼图，新的直线从原点到半径外的一点，进行分支判断，获得向左还是向右延伸，获得文字绘制的起始的数据为起始点，使用y值减小使数据放置在横线上方。
18.绘制图片的方法：Drawimg();
参数有三种：第一种三个：（img路径，图片左上角的x，图片左上角的y）--（img，x,y,w,h）----(img,x,y,w,h,画布x,y,w,h)-----必须使用在img.onload=function(){}；
19.使用画布九个参数的方法，可以画一个精灵图的效果，画布截取其中的一部分，其他的隐藏。
20.逐帧动画，一秒24帧（电影就是这样），最佳效果。在一个画布上，现在原来的画布上显示第一个，再去显示多个，这样就是。flash逐渐的推出历史的舞台。在苹果公司明确表示不支持flash了。
21.使用动画或者延时调用的三种方法，最新学习的一中是（function()r{requestAnimationFrame（function（）｝）（）；
22.先在全局声明一个变量为某个值，在一个延时调用的函数内部使用++，可以实现for循环的效果。
23。两个状态的方法，一个是save，另一个是store（）；执行的额顺序是栈的方式，第一次调用restore（）；获得的是最后一次使用save（）；的属性值。
24.使用canvas设置图片的平移。ctx.translate(100,100);作用是平移初始坐标原点。在使用了平移之后的所有的使用坐标的图形都会发生平移。
25.translate
5.14html501===============================================
1.strict，严格模式，使用标签的闭合，包括单标签也要闭合，另一个是doctype声明是html。另个版本宽松版本，可以不闭合，反正，不要大写就行，html5是简洁与宽松的。根据遗忘的习惯就可以。
2.w3c验证网站：validator.w3.org
3.语义化：让标签更加容易被搜索引擎以电子辅助设备识别。标签名与标签的类名，填充内容都会被浏览器识别，浏览器会根据某些标签内容来抓取该网站去显示。使用：h5使用语义化有一个巧妙的方式，直接把具有语义化的某些标签直接作为一中单独的特性标签。比如---section--header---nav--aside---article---footer---这些统称为语义标签，这些都是新的标签（相对的是之前的xhtml）。标签仅仅是充当了语义性，没有任何的自带样式。
4.怎么使用h5？跟之前一样，过一遍h5的标签，之后见过的大部分都是h5标签，过一遍会熟悉好多。
5.开发过程，一般都是chrome浏览器，如果使用h5来些网页，在ie6是不支持的，在开发中如果定位用户在ie6以上，就放心使用h5，如果有ie6用户，就不要使用h5.可以使用兼容。使用一段兼容的js代码库，可以在ie8以上兼容。这个是有条件的加载，如果不需要，起步是浪费时间。
6.需要注意的是尽量避免在全局就是在一级标签中使用h5 的便签。可以这样向，当你使用了div，这样就算底部版没有兼容个，或者兼容代码出现问题，也是可以显示大体的框架，不至于一堆文字在现实。
7.一段检测代码，在ie中可以识别这样一段注释代码，在别的浏览器识别不了，但是别的浏览器也不会傻到不支持h5，所以，使用这样的兼容代码，可以完美的解决。head中cc:ie6--tab，可以直接输出这一段兼容代码。
8.自定义标签，属性名随意，原理在js代码中，使用document.createElement("zidingyi"),这样把这个自定义的便签添加到页面中，使用innerHTML来填充到div中。这就是为什么不使用h5标签在全局中。
9.ie使用兼容代码可以识别标签，但是这些标签的block属性默认的是行内元素,但是使用的时如果你要使用clock需要强制display=block；
10.表单：之前的form，下面有很多属性。form中label标签使用是一个核心。之前掌握的表单的标签大多是input，现在使用新的input属性，可以实现新的功能，比如type=date，可以实现在表单中弹出框。label的for属性，指向input的id属性值，可以在点击的时候直接链接到该input中。
11.http//:www.baidu.com/index/index.html?name=lisi&age=33;协议+
12.避免沉迷与h5，这就是为什么原生的魅力总是那么迷人。一方面是兼容性，另一方面是代码自我保护闭源性。针对用户浏览器+网站不可被访问型=选择h5？补充一点，自带样式的标签又不可以改变样式的，尽量少用。
13.input的id==label的for，datalist的id==input的list。顶级标签框框---
14.多媒体的标签：一种是音频一中是视频，有兼容问题，可以在video,audio标签中添加sours标签，添加地址，在标清安的开头标签中可以添加属性，用来显示控制台与自动播放。
15.使用索引的方式来设计tab，这样的耦合度很高，不好，修改一部分后影响很大，解耦操作就好似降低代码的耦合度，那么，在h5中可以使用心得方式来设计tab，自定义属性来建立tab标签（多个a）与连接内容之间的关系，这样不使用索引，就可以放置后台数据传过来的时候顺序不对，但是id是唯一的这种数据。
16.怎么使用data-cont这个属性，第一段代码标签设置自定义data属性，下一段代码可以设置id，用来被dom操作，不受index的限制。
17.h5的精髓就是简洁明了。
5.16html502===================================================
1.使用dom的index的申明可以获得对应的其他标签的属性，但是使用h5，可以实现calssList.add();这样的方式获得设置的id。使用规则：
2.一条不变得规则，函数不调用永远不执行内部的函数体，
3.快速使用沙箱的方法，在一段代码中，使用一对小括号，包含函数体，在自调用的调用括号中参入实参，在形参中也传一个，在函数体重设置这个形参的可变的数值。
4.前端的学系的方位，前端的额面向对象，跨浏览器（andriod与iphone），兼容性问题（ie，chrome），一个新的api，不同于普通的api，是一种高级的api，h5的api不是为了摸一个特定的应用场景的设定，是为了全局的属性设置。
5.对媒体的全局api使用实例：<video  ></video>,在可支持的浏览器中，显示的默认央视也是不一样的，这就需要使用计算的】方法实现设置同意的样式。需要提供给操作视频的接口---有多个，为音频与视频同时服务的，可以实现改变视频窗口的样式，比如颜色，大小，位置，---原理层面是使用了一套准备好的代码框架，创建的一大堆div盒子。
6.什么是新方法的新api，针对型的标签设置的某些专用的api，也是，光是创建一个新的标签却没有个人能更好的，.html的第一个组成部分是所有的标签，第二个部分是jascript的API，
7.所有的on事件都有自己的触发机制，ontimeupdate目前的播放位置（进度）发生变化会触发此事件，类似于XMLHttpRequst中onreadstates的触发。在播放过程中一直被触发，这个根据html5一一对应的api的使用，也是使用js来实现的。这些api的上一级对象是获取的video标签的元素。在播放器的界面中，有多个div，可以在div的元素中设置点击事件，事件函数中使用的是新的api，比如设置播放，设置展厅，获得当前的事件，当前的进度条的改变，重新播放，等等，这些在视频与音频中都是公用的。
8.新的api为什么是函数，在js中，所有的api是23个，接口怎么用，提供一个对象，对象下面有属性与方法，使用的时候直接使用就可以了。
9.制作一个需求，加在前使用一个等待的logo，加载后可以播放，原理是使用video为隐藏，背景为一个动图，加载完成后display为block。
10.补充一点，所有的事件都会有触发机制，只是触发的条件不一样就对了。
11.字体图标中，引用的名称会使用在calss属性中，使用js改变类名，就可以改变图标的显示样式，使用的方法是，onlick执行的函数进行一次判断，存在性的判断，选择执行不一样的连个函数，这样就避免了使用多次绑定。
12.实时的获得当前的播放进度，使用video.ontimeupdate = function(){},只要不停一直在调用内部函数，单位是秒。先要获得视频的总时长，video.duration(),其次是cuurrenttime(),
13.在处理中，获取数字与总数的比例，获取这个数字，在dom中，使用样式的计算。
14.程序的执行有顺序，所有看待吗的时候也要根据程序执行的顺序进行解读，不断保存新的值。
15.案例实现的方式，从前到后，一起时播放与暂停的按钮的切换，其次是数字的显示用到秒与时间的格式转化，接着使用两个数字i，在js'中调整样式的比例宽度，使用%就可以，是相对于父级元素的额大小，oncanplay是事件--视屏可以播放的触发。
16.目前来说，函数的使用一方面是返回一个数字用来被其他的函数调用进行计算，或者是返回了一个dom'操作，可以直接控制元素的样式改变。---另一方面是没有返回值，直接在调用函数中使用命令处理或获得的元素与数据，相当于改变的一个链条，但是不是返回值的计算，console.log，或者write这些输出，包括innerHTML这样的都是在输出，也就是说，在一个函数内部，三种，一中改变值，二中改变输出，三种return一个可以操作的动作。
17.改变一个样式需要使用样式的获取，与样式的数字的值的映射。
18.获取document--document.docmentElement.
19.遇到过冒泡遇到的事件鼠标移出太快，用到了document去设置事件，在关闭事件上，只可以使用document.dom来关闭。
20.w3c是一个制定标准的机构不是浏览器的厂商，所有，对于docuemnt.fullscreen,在语法中使用的是document.webkitisfullscreen.知道，在语法中，h5的方法需要使用调用来完成业务逻辑。
21.使用h5的判断用户联网没联网可以使用
22.新的事件注册：onchange--把包括了值与行为的改变，必须是值的改变与焦点的同改变，而且，值不变焦点改变只触发一次，值改变后在触发一次。
23.文件表单，使用multiple。一个新的方法，
24.浏览器可以解析一个url的内容，包括了文件的类型与值，是很长的一个源代码。直接把这串源代码放进去也可以显示出文件。那么，我们就可以把文件上传，在获取到源代码的变量，直接添加给一个元素，就可以实现预览的效果了。可以把二进制的一对代码放在src上，计算机也是可以好识别。
25.html5，地理定位，html5中的高级api，要么提供新的api，要么在原有的基础上添加，要不就是原来的对象就有这个属性或方法。window.navigator.geolocation---两个单独的方法，一个是getCurrentPosition，只获得一次当前位置，另一个是watchPosition实时获取，重复执行，两个方法，需要传参数，-----第一方法的两个参数，第一个参数是获取成功的函数，第二个参数是获取失败的参数，
26.凡是需要获取用户信息的指令，都是要通过用户自己去点击验证的，比如，传一个文件，或者获取一个当前的地理信息。用户可以在设置的位置属性这里关掉自己授权的地理信息。
27.翻墙软件，可以跨过中国的网络墙，实现访问国外的服务器的资源，这些网站都是中国网络资源没有办法访问的。
28.获取用户地理位置的方式是有多种的可以通过ip地址获取，不同的地域ip值不易牙膏，或者gps定位，或者wifi也可以获得地址。通过以上的方法获得定位pc端注定是要粗略的，没有gps而已而且还ip范围太大，wifi定位---一块区域，wifi的ip地址上，具有对应的地理信息。最精确的还是gps定位，在移动设备获得地理信息
29.一个形参在函数体中公的输出改变它的输出形式是怎么回事，比如e==window，position==GeoPosition。
30.使用百度的api，--页面的script，src属性添加地址-- 获取第三方的地图库。使用百度的库，获得的也是百度的js库中的方法，获得的坐标。
31.使用bom的方法，可以设置历史记录，这样的方式可以改变一个url地址，页面却不刷新，干嘛的谁知道呢，使用bom中的方法，可以省略window，直接在navigator，或者history后面直接使用方法，传参数。
32.var btn = document.querySelector('input');
btn.onclick = function (){
  history.replaceState({ },'','/abc');
}这一段代码的特点就是使用新地址，不会增加历史记录，使用pushstate可以增加一条记录，使用这些事件，添加给window对象。onpopstate
33.一个非常重要的点---开发网站的好时候金叉个的存一些数据，把用户的数据进行存储，持久话的存储数据---只要不删除，就不会有期限设置而删除，h5提供了永久性的保存用户数据----window。sessionStorage。setItem()可以存储数据--window。sessionStorage。getItem()---window。sessionStorage。removeItem()---window。sessionStorage。clear()===。
34.session与sessionStorage没有关系，json与jsonp没有关系。主要是localStorage，永久，sessionStorage-5m暂时
35.实现视频播放器的全屏，使用包括按钮在内的大的层级显示模式为fixed，left，top，w:100%h:100%。
36.为什么你要做动态网页：打个比方，网页版的网易云音乐，使用静态，首先实现不了音乐信息，其次实现不了乐曲切换，再次，实现不了歌词滚动，最后，实现不了音乐的下载。致次，动态网页就是只写变量与占位符，不填充数据。
5.17html503========================
1.网络状态：通过网络端口的状态可以获得当前的设备是否处于联网状态--属性---navigator.online返回值为true或false--事件--online可以监听联网（断网--》联网），offline可以监听联网（断网--》联网）----
2.文件读取--通过FileReader对象可以读取本地的文件（处于安全考虑，不可以主动地获取本地文件），一般是由用户做出选择后再进行读取，用户可以使用input type=file，这个标签来选择，----假设用户选择问价，要实现需要以下的几个步骤，var reader=new FileReader();//接下来使用reader下的各种方法--reader.readAs---reader.readAsDateURL(fille[0]);//---当前的图片文件---//读取问价是需要时间 的，通过onload可以会的读取文件的状态，读取成功后会触发onload事件，
3.历史管理-----历史值得是url的变化，地址的每一个新增的地址，历史就会增加一个----a.html->b.html->c.html----通过history.go(),history.back(),history.forward(),可以控制前进与后退，再html中对历史的管理有了新的操作，可以新增历史的改变历史。通过history.pushState()可以再原来的历史上新增一条历史。---history.oushState(数据，(标题一般不写),'URL'),----通过hiseory.raplaceState（）可以将当前的历史记录进行替换，---使用popState可以监听前进或者后退的操作，当监听到后，可以出发，设置函数就可以处理函数体。
4.地理定位，html5可以获取用户当前的位置信息，（经纬度海拔），通过getCurrentPosition（）可以一次性的获取用户位置信息，使用watchPosition（）可以持续的获取动态位置信息，这两个都可以传递回调函数，成功与失败都可以传递三个参数a.回调函数（成功）--b。回到函数（失败），c.对象（包括配置信息，例如精度，周期，超时）---以getCurrentPosition（）为例，navigator.geolocation.getCurrentPosition(function(position){ //这里有经纬度与海拔 },function(err){//这里包括了失败的原因})；
5.web段落存储----持久化，将数据长时间的保存，后端语言中一般使用数据库来实现数据的持久化，也有可能是文件的形式来保存，作为前段，有需求来保存的数据，以前需要使用cookie的方式来实现cookie在网页发起请求是作为请求头进行传递，cookie一般不要使用，cookie是使用字符串的形式来传递的，使用起来非常不方便。cookie会携带全部的数据去验证，会拖慢网速，现在使用sessionStorage，localStorage，IndexDB，webSQL----其中sessionStorage与localStorage使用的相同的方法来实现数据的持久化----setItem（）设置一个数据--getItem（）获得一个数据---removeItem（）删除一个数据----clear（）清空数据----key（）查找一个数据，我们一sessionStorage.setItem（'name','itcast'），只可以使用字符串形式的数据----如果想存储一个json格式的信息，----var obj={age:10,name: bingbig};---sessionStirage.setItem(obj,JSON.stringfy(obj));----sessionStorage与localStorage的区别如下----存储大小--5余20M---生命周期---关闭当前窗口与永久存在除非被手动清除掉----数据共享---只想当前的窗口与同于领的所有的窗口---补充sessionStorage是前端技术，是在浏览器中存在需要设置，是孙处数据的一个机制，session是服务器端的技术，是一种会话机制----cookie与sessionStorage与localStorage都是浏览器端的。
6，补充一个知识点第一个
7.css3，html，css，javascript都是先有组织与规范，然后浏览器的厂商负责将这些规范实现，这就导致了不同的浏览器在实现的似乎就有不一致性。即使同一款浏览器的不同版本在测试规范中，只有测试没有任何的bug才可以投入采用，比如width，没有正式通过之前，往往是通过私有前缀的方式来使用，即-webkit-width-（表示目前属于测试阶段），不同的浏览器的厂商的前缀是不一样的，后来运行良好，才把前缀去掉，不同的浏览器的前缀不一样，ie---ms--，chrome--webkit--，firefox-moz--，opera-0-，有时候我们会遇到别人的网页写法是兼容处理，在chorome的56使用width，在54使用的是webkit-width，就在在属性中，写上两条width属性。
8.如何查看文档看参数，看格式，看数量内容。
5.19css3=====================
1.使用background-size可以设置背景图片的大小，但是在标签中使用的图片是不可以调整的，只有在标签中使用width与height来修改，使用背景图片填充的方式来做，属性值可以使名词----cover，contain，也可以是两个数值型的参数可以是三种单位的任意一种。使用cover是根据最大值来缩放图片，溢出的会被隐藏，使用contain根据最小值，缺省的地方留白。
2.背景图片默认是从边框内边缘开始填充，使用background-origin,可以改变填充的区域，背景图片的定位坐标是以左上角开始的，设置新的参考坐标原点，设置一个属性，background-origin:border-box,这样的背景图片的填充就是以外边框开始填充。使用padding-box是以边框内边缘开始填充的，使用content-box是以padding的内边缘开始填充。
3.使用背景颜色的填充，默认的是从外边框的外边缘开始填充。使用background-clip可以裁切背景颜色的区域，默认的是从border的外边框开始的，属性值：border-box,padding-box,content-box.分别代表的是三个背景颜色的区域，这里的属性哈可以使用数值型的计算方式。
4.案例：使用多个背景图片拼合一个完整的相框----可以为一个盒子设置多个背景图片，使用多个background-image来设置属性，原理是使用属性值使用逗号隔开的方式，多个url(./images/img01.png) left top no-repeat,``````.
5.过渡效果：也称之为逐帧动画一秒24帧，是电影的最佳效果，使用样式的逐帧动画可以实现js定时器的制作，根据时间的改变样式，欢动与渐变都用到了定时器，css3使用的是补间动画，原理是给定一个开始给定一个结束的状态就可以自动执行这个过程，开始状态不用说，宽高背景，终止状态宽高背景，加上一个出发条件，这个条件写在终止状态的选择器上面，在开始状态写上一个transition：all 1s这个属性，属性值是一个周期时间。最难的在于如何添加一个触发器，使用选择器中的hover或者在js语句中使用绑定事件。他的变化是根据当前的属性值来开始到达目标值得渐变，不会回到初始状态再开始渐变。
6.一个问题，为什么transition在触发后设置只有一次效果，这是因为下面的触发器不包括上面的属性变化。
7.使用transition可以实现的是tab的淡入淡出，弹出撤回，配合after可以实现不占其他元素的位置，而弹出新的元素。用来制作网页的点击弹出下拉框，很棒。.box:hover .box1{xxx}
8.解释一下为什么使用all，全部属性改变都是固定的，使用多个属性与时间的搭配，可以实现立体效果。有些状态不需要使用all这昂来实现，必须使用单独的属性加上时间。使用两个时间的意义在于，第二个时间表示的是延时操作。根据这个组合，可以实现很多的属性的简便的等待，可以一一改变。比如简单的实现一个小球的移动。
9.在使用一个动画的额过程中，最好使用定位这个样的话，就不会影响到标准刘的布局。
10.知道时间，路程，还有 一个速度的问题，使用时间的下一个属性值，linear表示的是线性的匀速，默认的是ease表示的是加速。（贝赛尔曲线包括linear，ease，ease-in,ease-out,ease-in-out）,分别代表的是运动的效果是什么样的速度。----样式 时间（延时时间 速度）
11.这是动画，还有一个是旋转，trans系列都是很棒的动态效果。需要重点掌握。
12.案例树林风---两个背景，定位切换，缓动动画。
13.transform表示的是变形，属性有rotate（deg），translate（width，height），scale（倍数水平，倍数垂直）。一般来搭配上transition的属性来实现 。
14.使用定位实现的特效都是独立出现的不去占用标准流的位置。使用2d动画都是有映射的出现，有一个固定的位置的元素，可以控制动画效果的元素的维持稳定不会脱离。
15.使用旋转必须设置---原点（transform-origin）-周期（transition）-角度（transform：rotate（360deg））----其中原点的属性值可以死left，right，top，bottom，也可是xy的值；
16.不管是那一种样式装换，都是以之前的原位置作为原点，所以使用transform-origin的属性来修改原点可以实现中心改变，使用三个属性的结合也可以实现更加酷炫的特效。
16.今天用到了一个css变量的使用，是一个类似于计时器的功能，保持一个万花筒的持续转动。
17.根据所有的子级元素的高都是参照腹肌元素的大小来设置子级的百分比的大小，在默认情况下，块级元素的宽1366，高0.
18.  
5.22css3======================
1.伸缩布局：在块级元素的布局根据横轴与纵轴，与定位于浮动一样，控制元素的位置，有什么好处？在传统的布局中，三盒子----盒子两端对齐，中间盒子居中，设置float：left，margin-left。
2.nth-child(n)----解释虽然看起来是这个标签的子级的集合，但是整整的是父级元素的所有的子级。动力嘛？
3.对于排列模式，一般用在父级元素，子级元素可以按照规定的横纵轴（flex-drection（column）），align-content(end，starr)上下位置，flex-content（end，start）左右起始，获得
3.对于排列模式，一般用在父级元素，子级元素可以按照规定的横纵轴，align-content上下位置，flex-content（end，start）左右起始。关于主轴的方向的改变有属性为这（flex-direction--row-reverse水平方向转换排列变成从右到左【默认情况的上下到左右】----clomn-reverse--纵轴排列从下到上）
4.在全局的section属性设置一个display：flex；一个技巧
5.通过flex-direction调整的是水平伸缩的趋势布局方式，效果是调整具体的元素布局，就像word中的文字的版面的左对齐，居中，右对齐，图片的环绕把多余的空间分配，两者组合使用，使用align-items可以调整在纵轴的方向上的样式，顶部对齐，底部对齐，垂直居中，在换行属性flex-wrap属性中，值有wrap强制换行，但是挤下去的还是是属于与nowrap两个值，默认的值是nowrap（效果是在同一行中，排列并且挤压）。
6.为什么在伪类的后面不可以增加伪类属性，因为伪类本身就是一个交际选择器，两个伪类在一起的意思就是，两个伪类与本身 的元素都在交集中，代表的是谁本身元素的操作，但是覆盖的效果导致无法接触到本身元素。
7.空间轴的判断，就是任何情况下，只要你是面对这个盒子，他的上下左右没有跌倒，那个就是面朝的方向上，轴的方向分别是右x，下y，穿出Z\。
8.为什么要使用preserve-3d，本身的盒子，是根据内部的子级元素来布局的不适用这个属性，就没有办法实现同事显示两个侧面这样的效果。
9.为什么，使用望远镜，景深perspective，这是因为不但要显示出来3d，还要显示一个更加近大远小的效果，突出视觉效果，就是用这个实现。
10.前端的hank，就是使用特殊符号，为不一样的浏览器设置兼容的性能，还有cc：ie6，这样的注释可以被识别，实现的是兼容新元素。
11.使用display：flex；设置justify-content：center；控制水平轴的位置，align-items：center；控制的是纵轴的位置，具体是属性，继续补充。
12.使用通用型的浮动清除：就像统一性的设置一个类名，去设置一个元素的width为浏览器页面可视区的宽度一样，使用一个约定的clearfix类名,第一种，使用overflow，float，position设置给父盒子可以使他获得高度，这样不怎么用，overflow也有问题，就是子级的子级如果使用查出边界的效果，就会出现也被hidden的现象。【重点】：对没有高度的父级元素，或者被卡主的元素上使用伪元素的clear：both，用法，.clearfix:after{content:'';display:block:clear:both;可以选择性的设置宽高}。----徐亚注意的是content属性必须使用content，内部的内容在不一样的浏览器中显示不一样，在两个引号中使用空格。这样的写法还是有点过时。最好用的还是bootstrap的清除浮动。【重点】：clear:fix:after{content:' ';display:table;}.----并且塌陷可以使用设置父级盒子的定位，浮动，overflow，还有一个使用伪元素。同时共性的解决两问题。在标签中添加类名为class=clearfix，在css中，设置clearfix:before,clearfix:after{content:' ' , diaplay:table},下面在补充一个clearfix:after{clear:both}.用法是在每一次使用的时候添加类名就可以。  
13.老生常谈：页面的所有的盒子必须设置宽度。高度可以使用撑开的方式，最后设置清除浮动，或者设置posoition的relative。
14。flex的作用就是把父盒子的剩余分成flex的值得和的分数，其次设置值的比例大小。什么是剩余部分呢？就是子级盒子如果没有设置宽高的全部就是剩余，有设置宽高的其余的空间就是剩余。
15.属性连写：flex-wrap。是flex-deriction与flex-wrap属性的集合。
16.order属性，用来排序，对选择的同级的盒子使用order属性，可以从小到大，小得在前面。order：xx；
17.使用规则：a，制定一个盒子的属性为display：flex，b，设置属性盒子的元素的布局方式，不如flex：direction与flex-wrap在一套，c，设置横向样式，纵向样式，
18设置全局了可视区的铺满，使用html，body的height为100%。
19.就像不同的音频与不一样的格式，字体也哟格式，.ttf----.otf----.woff----.eot----,是因为不同的浏览器对他的支持程度不一样。如果使用web字体网络字体应该怎办？下载好字体库，在style中使用@font-face{}中添加font-family:xx;url与src属性，配置好之后，就可以在css中像往常一样直接使用就好。
20.web字体的坏处是，汉字库，特别大，英文字体库使用还好，毕竟26个英文字母而已。还有一种是图标文字字体库，可以获得字体直接就是一个小小的小小的图片啦，而且还可以基层颜色与字体的大小，直接去修改就可以，不需要使用宽高这种属性。完美的字体属性。
21.react的理念就是组合html，css，js，但是另一种说法是分离这三者，在框架中，找css中占据顶级位置的是bootsreap，所有字体库，新的样式，css3的功能为bootstrap服务的不在少数。在js中最顶级的就是jquery了，还有react与vue，这就是三种不同的框。
22.使用网络引用字体，一个是使用了外部引用的库，在页面标签的文本中使用一个编码的形式来对应库中的字体，另一种就是使用添加类名的方式来显示一个文字，这两种方法各有好处，一个是可以节省标签，另个是可以添加一个独立的标签，用起来的效果也不一样。
23.产品就是使用脑子去做需求设计，ui前端，后台就是数据处理。最终目的就是增强用户体验。
24.语言阐述360动画：页面促使大小为可视区的大小，页面的第一块内容就是随着滚轮切换。不可以使用onscroll，因为不是用滚动条，监听不了，使用的正确方式是document.onmousewheel=function(){};但是问题出来了，怎么来监听我们每次使用滚轮的次数是多少也不可以直接使用多次的滚轮只改变一次，也不可以使很实用只滚一次就跳一帧。基于jquery的插件使用比较多，以360这个案例为例，【首先】首先实现滚动的动画，网上下载插件，吧插件放在index的文件目录下，选择jquerymin，该插件，放在script中，【其次】对照相应的页面要求的模式，插入到html结构中去，【最后】，将我们的css，类名，js语句添加，就实现，其实就是类似之前的模板。
5.25移动App01====================================
1.移动端的视口默认是980甚至更大，宽度小于980就不会错位。
2.移动端的浏览器主要有三大类：系统的，应用的内置（专用词webview&UIwebview），前端一般要配合人安卓is客户端，开发的app有些页面使用web页面，在手机桌面打开app，在进入app钱的有可能就是一个网页，我们在这里只做一个web模拟nativeapp，前端只做好，运维去调用这个页面，就可以嵌入到这个app中。
3.在手机端可以额外的安装一个第三方浏览器，这个浏览器具有自己的明显的特性。
4.关于屏幕的适配：在前端只可以使用css像素，css像素可以代表一个或者多个物理像素，我们更多的想要使用一个想多大小的元素来布局，不是使用一个绝对的大小的元素来显示，css像素就称之为独立像素，就是不跟着页面的物理像素，被强制的额放大缩小这样来来回回的，使用dveicepiexlrito公式为n*m物理像素=a*bcss像素。
5.做为用户是不会关心这些细节的，他们只是希望在不同PPI的设备上看到的图像内容差不多大小，所以这时我们需要一个新的单位，这个新的单位能够保证图像内容在不同的PPI设备看上去大小应该差不多，这就是独立像素，在IOS设备上叫PT(Point)，Android设备上叫DIP(Device independent Pixel)或DP。
6.真机调试：
1、将做好的网页上传至服务器或者本地搭建服务器，然后移动设备通过网络来访问。
2、借助第三方的调试工具，如weinre、debuggap、ghostlab等真机调试必须保证移动设备同服务器间的网络是相通的。
7.window.document.documentElement.属性==xxx；
8.---ayout viewport（布局视口）指的是我们可以进行网页布局区域的大小，同样是以CSS像素做为计量单位----ideal viewport（理想视口）设备屏幕区域，（以设备独立像素PT、DP做为单位）以CSS像素做为计量单位，其大小是不可能被改变----理解两个viewport后我们来解释为什么网页会被缩放或出现水平滚动条，其原因在于移动设备浏览器会默认设置一个layout viewport，并且这个值会大于ideal viewport，那么我们也知道ideal viewport就是屏幕区域，layout viewport是我们布局网页的区域，那么最终layout viewport是要显示在ideal viewport里的，而layout viewport大于ideal viewport时，于是就出现滚动条了，那么为什么有的移动设备网页内容被缩放了呢？移动设备厂商认为将网页完整显示给用户才最合理，而不该出现滚动条，所以就将layout viewport进行了缩放，使其恰好完整显示在ideal viewport（屏幕）里，其缩放比例为ideal viewport / layout viewport。
9.在IOS和Android操作系统上自带浏览器、应用内置浏览器都是基于Webkit内核的。
10.页面溢出的结果，一个是出现滚动条，另一个是被挤下来，另起一行。
11.移动开发的核心是屏幕适配，然而并未有专门的规范进行约束，一般是对现有持术进行归纳而总结出适配方案，四种方式一种是设置viewport的width制定一个尺寸，二是设置百分比的宽高被外边距，三是使用html的16px字体大小为基本单元，设置倍数为n的rem，四是使用网页的宽度等于引用浏览器的物理像素的宽度，内部元素大小可以使用。
12.准确的来说，没有固定的方案来设计移动端的样式，都是使用四种方案或者自己适合的方案，目前最重要的就是发粉笔与rem的使用。这里在设计移动端的时候，会出现一对bug。这是灵活性的设计，没有定式，使用固定宽度，要掌握自己要适配的浏览器的大小，一般是320,360，
13.避免缩放：width=decice-width;避免滚动：initial-scale=1;----页面的盒子不可以超出320px，因为现在的手机就没有超过320px的，但是后期的手机屏幕越来越大，使用旧版的320培训，会非常的丑。这种固定宽度的方案可行，但是不灵活，留白的地方不好看。----那么使用百分比的效果怎么样呢？宽度永远使用百分比，处理要使用双飞翼与圣杯，可以设置一个二维码大小，都是用百分比的宽度，一个问题，border不支持百分比，而且，所有的支持百分比的都是以自己父级元素的宽度为参考，包括自己设置的高度与是以父级盒子的宽度为参考的。
14,。尝试按照百分比的方案制作京东首页。网页图片分为ui图（点缀装饰），内容图（商品），将我们的ui图放在images，讲商品图放在另一个文件夹是一个好习惯。公式的ui设计一个psd的文件，自己仿照这个图片来制作，首先分析，在顶部的通栏这里，使用width怎么用？px？100%？具有margin属性的话，只可以用auto。
15.为什么设置了border-radius没用？？？给子盒子的最顶层元素设置，或者设置被覆盖的元素overflow。
16.解决设置了padding，盒子变变宽，以后不适用加减，直接使用box-sizing:border-box; 
5.26移动app02=========================
1.使用具体的像素会影响到高像素终端显示变小，但是使用百分比，就不会有大小的变化，永远都是相对大小保持页面比例，这两个可以交叉的使用，就比如js与jq，css与css变量。
2.怎么在响应式中实现真是的居中？首先在内部的文字设置一个line-height为1，这里补充一点，行高可以继承，使用100%，会把父级元素的行高转化的px，固定的继承给子元素，二使用1，可以吧这个行高等于字体大小的比例，继承给的是这个比例，然后现在没有默认宽高，就去设置paddig，就可以保证，所有的默认样式不会出现，就可以一直保持垂直居中。----这里想起来另一个万能技巧，在结构中的为了可读性会出现空白符，在设置一个font-size可以使其空白符清空。----伪类选择器中的nth可以灵活的使用n的变量，实现批量规律性的元素选择。----伪元素的使用，在一个有语义的标签的周围关联性的添加一个标签使用伪元素最好。不占页面的标签位置，可读性很好，比如在一个文字旁边添加一个图案。----一个哼行中使用33%，或者flex：1，都可以设置横向排列。----真正的开发中国，可以根据自己的需求来实现，怎么简单怎么来，如果是涉及到图片就使用百分比最好实现。----电商中li--a--img这样的布局最常用，以来保证了页面li的整齐，a可以实现跳转链接，img添加可以实现语义化抓取。----父元素使用了浮动，子元素浮动，父元素就由来高度。这就是bfc。
3.一般情况，使用padding来挤一挤元素，就还要在后面补充一个box-sizing;另一个类似的就是使用了background之后补充一个ground-size'bg属性可以连写，但是size这个属性一方面又兼容性，另一方面center/200px，这样的形式不利于阅读。----补充一个nth选择的案例，不是侄儿这一个系列的所有元素中国的第几个，值得是父级元素的旗下的所有的元素的第几个，这就是为什么有时候选不到你要的那个元素。----浮动的子元素使用的情况，前面的盒子浮动会影响后面的盒子，子级给自己是没办法清除子级的浮动的，clear的使用原理就是，清除其他元素的浮动影响，这就是为什么子级没有浮动，而且也改不了浮动的属性，只是让自己当前的位置不受到浮动影响罢了。----技巧：使用一段文字的省略以···来显示。盒子限定是了，文字大小也是限定了，多出来的文字显示不出来了，使用一种算法大于固定数值的问题以···显示，但是css中的一个属性是text-overflow:```,字符代替，直接剪切。----为什么引文的回撤换行没有效果，因为在英文中的显示是空格来进行拆分。----文字的显示的属性word-break:all-break;强制换行。---实现的效果就是多行文字中显示末尾的省略号，死淘代码，先是转化为超出隐藏，超出显示省略号，其次设置显示dis模式，与哪一行显示省略号，最后是垂直布局，与强制换行，就实现啦，哇咔咔。
4.布局方式：使用的技巧就是从上到下，依次把模块化的版式定好位置，最外层的框架结构先有，从里到外
5.实现需求----goole查询----找到文档----找到参数与模板----制作demo（自己写或者直接使用copy写注释）---应用在项目中。
6.详情页的布局与小模块的实现：布局的h5标签，css文件一个是index文件，另一个是base文件，还有一个demo文件用来测试----开发模式---小技巧：使用padding才可以使用box-sizing，margin是没有作用的。
6.三个相伴相随的属性：font与line-height，padding与box-sizing,background与background-size.使用技巧，使用lineheight不单单可以调整字体的居中，还可以使用文字无行高，padding用来挤压前后上下，在空包的地方使用定位设置一个图片的位置，最后使用精灵图设置bgi，在下方再去设置size,这样的开发模式可以快速有效的实现多种类似的电商网站的布局。
7.实现一个小的精灵图的方法，一种是限定了盒子的大小，添加图片，设置位置，调整上下左右的位置，另一种是使用盒子的位置为父级的高度，设置一个padding，使用background的clip，origin属性，设置为content-box,这样就是使用了剪切的区域与background-position的默认位置是内容区域左上角开始计算。
8.一个渐变的背景是怎么实现的，两种方式，一种是使用一个渐变的小竖条图片，另一种是使用线性渐变.
9.响应式布局，与标签的动态添加，是最常用的开发模式，一方面，标签的数量是不固定的，另一方面，显示的内容的不固定的，这就要求，在css布局的时候，要注意容错性，就是耦合性要低。
10.重绘与回流，createElement与innerHTML+字符串拼接的好处是不开辟堆空间，使用定位不会改变别的层级与标准流的位置，值影响自己的位置。
11.css3中的媒体查询，手机与电脑pc的打开方式展示的界面需要不一样，不同的终端称之为不一样的媒体类型pc端移动端。通过一条css变量或者link属性来这顶范围最后获得对应的识别，在对应的条件下执行符合的css样式。@media screen an（）{} ==link--media：screen and  （min-width/height/：980px）；所有的狂傲的属性的默认的样式参照的属性就是layoutview即我们的html的大小会被识别，根据设备的大小调整的是devicewidth与deviceheight这两个属性的值使用一个定值等于ideal viewport，还有另一个条件orientation：portrait竖屏（肖像模式）--landscape横屏（全景模式）--学无止境，学会从生活中回归，找到共性。
12.什么事响应式布局？就会说使用media的属性一一对应，得到两种或者多种不一样的css样式，最后根据用户的html的宽高不一致，显示的内容不同，主要是界面的呈现的内容大小与数量不一样，就是风格不一样。
13.是不是一个语言，原则是有没有变量，没有变量的不可以进行输入输出。为什么要引入css预处理器，因为伪类通用型的css语句，使用函数的方式，在剩下函数中使用已经申明好的函数，就可以模拟编程语言，在打的项目中，使用css预处理器，可以吧css的维护变得更加方便。
14.第一个css预处理器，less是其中的一种，用来管理和维护css，并且LESS是是使用node.js开发的工具，使用less，首先要安装node环境，这是前提，要想node.js环境，只需要10m大小，安装在英文路劲就可以实现。其次在cmd中运行npm install less -g.
15.安装之后，
16.使用一款你按的正确方式，选择官网的全新安装，在去找破解方法。插件的下载，使用命令条，在网上找使用ctrl加上1左边的按键，把赋值的代码加进去，下载好之后，shift+ctrl+p，弹出框，boxy them安装主题----chineselocal汉化----less2+less？？less高亮----boxythem active激活----add选择文件----install》package。
17.使用webstorm配置，直接创建less文件，打开后找到npm下的app文件的less。cmd文件，添加到可执行的文件中。
18.使用css解析器，里面可以写函数，函数一种是只申明变量，另一种是写函数，参数一个可以直接用，另一个可以申明默认参数，在调用的时候可以传参也可以不传参。
5.27移动03=======================================================
1.移动端的web与移动端的app页面不一样，web页面的手指默认样式都会出现弹出框或者文字的选择，在app中全部设置了取消，模拟的是nativeapp的效果，与ios与android的不同点是，卡顿，并且体验不太好。一般在更新迭代周期短，或者页面特效与滚动少的页面中使用html就好，使用js可以把默认的效果取消掉。
2.当你去购物的时候，就可以发现实现的效果与原理。在写布局的时候从来没有调整元素的高度，当我们开始制作详情页或者图片横向布局调整高度，百分比就不是最好的方案，目前的方案最主流的是rem，百分比不是亮点，能不能写好兼容移动，rem方案是最重要的。
3.最理想的移动端页面是没有缩放与滚动条，只要达到这个目标，就可以了，不缩放<meta name="viewport" content="width=devicewidth install-scale=1" > 不滚动，
4.使用em的原理，em参照的是当前元素的font-size的大小，因为字体的大小可以继承，在body的标签设置好后，再所有的标签中就可以继承，在所有标签中就可容易继承该字体，使用em就可以实现等比例放大。默认值字号是16px，那么，默认em就是16px。为了计算方便而已。余rem的区别是em是随动的rem是跟随root根节点的字体大小为单元大小的。rem的由来是本身是一个单位，是一个固定的单位，只需要在html选择器改变font-size就可以啦。
5.回顾使用less。语法方面，使用@变量：值。来申明，函数--选择器 （）{变量：值}；可以传参也可以不传参，使用的时候可以变量，函数，普通键值对混合使用。使用less的范围是一个样式多次使用，
6.ui给图片，手机的尺寸不一样，就是宽高的比例是不一样的，那么布局的时候，显示的样式也不一样，这里就用到了之前设置的link，或者@media属性来调整显得多个样式之一。这就是媒体查询。
7.使用层面，从制作demo开始。
8.ui给的图片一般是640以iphone5手机为标准与750ipnone6，页面的比例不一样的话，页面会出现模糊的拉伸，图片单独处理，就不会模糊，布局结构按照640布局。案例，UI图给了宽度640,，手机端宽度为1080，保证rem的单位大于12px，并且不要小数。-----使用20-640，使用25----750.
9.使用less.js可以直接使用，功能：编写css样式，原理：在js中执行代码，js与less是两个文件，要使用主动读取的模式，就要使用js中的发送请求的方式，请求服务器的形式去读取less，再去解析，再去返回css文件。间接的形式去获取。他的实现，在开发间断在使用less.js实现，在开发完成后，会：使用：1。引入link中的href为less。2.在script引入less.js。使用注意：服务器的原理，使用的是跨域的原理，必须在服务器的模式下打开，以后就是用服务器的模式编写demo吧，亲。3.开发过程可以直接这样使用比较方便，在项目上线的时候，使用copy整个less，放在less解析的css文件，把这个引入到html。
10.多次psd进项开发，现在要使用psd来开发，这就是工作中的实际用的一个东西，在开发之前，都会得到那些信息与资料，这里有两个，一个是640素材，一个是750素材。编辑页面的效果前，先分析需求，大概要采用什么样的代码实现，有这么一个分析的过程。屏幕的比例要等于字体大小的比例，就是一个单位的大小就是比例的乘积。
11.最终的css使用方式，主页面引入一个link，在link中的css中使用@import './base.css'。@import本身的作用。
5.29移动端04=======================================================
1.手势事件：touchstart，touchmove，touchend，触发的事件又有targettouch，changedtouch，touches，三个，根据功能的特点，封装这几个函数，手势封装：点击tap，doluetap，wipe，分别的单击双击，滑动。
2.使用zepto.js，可以实现五个常用的模块的封装分别是ie（手机浏览器的windowphone），zeopto，form，event，实现一个添加可以直接在script中添加一个src，api的路径为额外的js文件，另一种方法是打开make文件，修改splite前面的字符串，添加或者修改都可以，修改完之后，在命令窗口执行，npm install---->npm run-script dist---|.更新引入的文件的zepto.js。
3.一个是利用索引，进行相关的计算，可以得到对应的渐进值，用来处理动画或者dom很好用，使用框架进项实现，代码量很少，
4.使用了锁头：实现在开头申明的false，过程中改变布尔的变量值，最后在另个一个限定函数中改变不二变量的值，就完成锁头。
4.使用less写css，一个是学会使用嵌套，另一个使用rem单位的强化。逐渐渐进
5.31移动开发05=====================================================
1.标签的自定义属性data-xxx属性的功能，使用原理。
2.ipnone与Android的手机页面的制作不一样，ipnone的页面是制作一个成手机页面比例的大的网页，在meta的属性中initial-csale为一半或者其他的比例。是因为ipnone的手机的尺寸就那么几款，安卓的款式要多的多，使用百分比的模式、
3.移动端的类库：zepto.js，为什么避免使用外部文件，会造成网页反应变慢，体积变大，如果没有自己的最休息的代码，做不到效率高于类库，就使用类库就是最好的。
4.ios与前端一起来完成移动app的开发，前端的web在更细速度上有自己的特长，在app中有web的属性的默认属性就是web网页，利用js的类库，iscroll可以制作网页的滚动条效果。掌握的是学识使用插件的思路与方法，那么，怎么去使用与思路分析？首先遇到不会的第一借助于百度，搜索关键词，iscroll，中文的文档与引文的文档翻译过来，我们开发在语言上，不一样，所以在语言中很多时候就是英文的思维方式来组织的，不过理解上面没什么难度，试着去积累与翻译，不要抵触。到后期可以估摸着看着文档内容。官网会有详细功能，udemo，iscroll就是惯性滚动与其他的功能，了解这个之后，使用github的源代码去下载分析使用，这个思路符合自己。----之后制作一个demo，简单明了目的性增强，实现这个单一功能。----满足结构---引入js，script中去new iscroll（'类名'，{内部添加多个对象，分别是键为变量键，值为布尔值}）.默认的是使用鼠标或者手指滑动去滚动。
5.github是一个开源社区，免费共享的模式，源代码公开，把自己的源代码文件长传，世界范围的程序员或者其他可以在这里查看别人的源代码，开发者在这里制作的build---构建里面包含的是用户要用的直接功能性文件，iscroll.js，包括很多版本，打的晓得都有，大与小，各有各的优势，iscroll有五个插件，都具备基本功能，在扩展功能上有差别。
6.js的复习，就是从开始的数据结构与流程控制，到后来的一个事实赋值，一个是调用，赋值涉及到变量提升（全局与局部）与顺序性（函数名，参数，变量名），类似的函数的调用，使用call，apply，map，filter，every。
7.移动端的点透现象，影响比较严重，就是在手机端click的延迟，会点击到别的层级，这样就会出现错误的执行，比如付款---。
8.设置了meta的width与initial-scale才可以出来touch事件，另一个需要注意的地方是，点透与冒泡的区别，冒泡必须赋值盒子，点透严格意义上指的是，在zindex上覆盖的时候，点击取消显示后，就会出现下方的层级被点的情况。使用插件fastclick，或者zepto的tap解决快速点击，爱网页端出不来效果，但是在真机调试，可以出来效果。直接引入fastclick插件，内部使用？？？？差一个
9.chrome32+浏览器使用meta的width=devicewidth，直接就组织了click的delay属性300ms。
10.制作小点点的轮播图，就可以使用伸缩盒子。
11.分析网页的特效的实现，基于插件需要弄清楚所有的参数的使用，但是还要分清楚内部实现的原理。
12.slide轮播图的封装div.pic$*10====>得到的是一对类名不一致的div盒值。
13.ul>li*8<a[href='javscript:;']>img[src='./images/xxx$*8.png' alt='name$*8']==>得到的是一对img
14.这样的形式类似于正则，你的正则的复习还没有结束，今天中午就别回去了。
15.搜索一下，解决特效中的index的方法。
16.关于在轮播图中使用一个添加重复第一张，是因为，在最后一張的切换，需要在前一张换到一般的时候，后一张需要显示一半，直接切换到第一张实现不了，但是在切换到第二張的时候，第一张可以瞬间切换，因为图片一样，所以，看不出来替换，如果直接使用替换，移动的切换，岂不是图片不一样了吗？
17.如何解决在响应式设计的i的劜的宽度的为例的10倍，但是ul的大小为一个例那么大？设置里的width为可是窗口的大小，ul的大小是里的width的数量的倍数，hidden与float就可以实现了。
18.全局申明，在函数内部不再第二次申明，直接修改后，全局的变量的值，就被修改了，使用在多个函数的模块化，尤其方便。
19.把函数作为参数，在函数的内部使用，或者直接在一个函数内部使用一个函数，都是函数的回调。
20.页面的布局方式静态（固定尺寸）----流式布局（百分比加上px）----自适应布局（rem）----响应式布局（根据media1200px----980px----768px----767px----460px去渲染不同的布局页面的css）。
21.在实际开发，前端与UI设计相应式布局，尺寸的大小，由最常见的全显示，半显示，单独列显示的模式。根据html也就是screen的width的改变而调整。 
22.另一种制作一个玩野的方式的模式：打开一个网站，观察他的页面的所有的元素的高度与宽度，就去模仿。
23.一个完整的less，sass的变量有一个特点就是，变量只可以申明一次，接下来不可以进行赋值 ，则可以进行变量调用，含糊的使用一般用来设置通用型的属性，比如，设置一个清除浮动，严格意义上来讲，这样的方法使用类名更加合理，但是，使用函数也可以，那么，什么情况下使用函数比较合理呢？最明显的就是设置一个边框圆角，在最上面申明一个函数，可以被传参的那种，在后面的所有的可以设置圆角属性中直接使用这个势函数并且传参数就可以。发散思维：另一种或者其他情况呢？另一种情况，一些无关但是却要合作设置的属性，padding与box-size；另一个background与background-sizing；两个都可以设置一个函数
24.在less中使用&；last-child{}这样，可以获得当前的层级的父级的下面的所有的第几个。哈哈，有点绕。但是这个就相当于this.parentElement.lastchild.----
25.使用swiper这个框架或者类库，需要注意的是，使用的结构的类名不需要单独写自己的设定，在已有的标签上天剑自带的类名就可以（）
26.width宽度的设置，一方面使用的是固定的数字，另一方面使用的是范围的数字max-width或者min-width。
27.封装轮播图的思路是宽度与索引的获取和style的设置和锁头，封装选装木马的思路是设置定时器，opacity，全部动画的时间外加一个锁头，封装tab切换的思路是，获取索引和缓存索引，分别出现显示与隐藏。
28.响应式
29.不使用flex，可以得到内部盒子，这个hack没啥原因，就是可以，display：inline-block；与text-align：justify；最重要的一点是，在后面添加一个元素，如果满行，必须添加一个inline-block，设置宽度为基本盒子那么宽，高度为0，也就是必须满并且换行才可以。
30。复习：使用原型属性中的方法与使用构造函数中国的方法的不通点在于：构造函数中new去调用，或者说是实例化，都是在开辟新的空间，但是在构造函数的原型属性中国添加一个方法，就不需要开辟空间了，就实现了共享的属性。
31.预解析包括函数的变量提升与函数名的提升，函数名的提升，在函数前调用会导致报错，变量的提升，在全局范围内，上方没有的话，就会undrfined，与之对应的是函数内部的生命与全局的申明，以及函数内部 的隐式全局变量，在函数内部，var的话，就会导致外部获取不到，那么全局如果有声明就会undefined，全局都没有var，只会报错，在函数内部的隐式申明，又在全局中有声明，那么，就会修改全局的数只。
32.构造函数中都有一个属性:prototype,叫原型,这个属性指向的是原型对象，prototype是程序员用,用来调用其中的方法，或者设置新的属性。----实例对象中都有一个属性:__proto__,叫原型,这个属性指向的是构造函数的原型对象，__proto__是浏览器用的，自带属性，属于被添加的方法之类。
33.关于一个构造函数，普通调用与实例化调用的不同点，就像一个普通函数一样，直接调用的this指向的是window，而使用new来调用，this指向就改变了，就是这个构造函数被实例化后的一个具体的对象函数。
34.div#dv--->HTMLDIVElement---->HTMLElement---->Element---->Node---->EventTarget---->object.
35.与解析的另一次解释，全局与局部互不影响！！！隐式申明属于全局（window）！！！输出一个变量优先在最近的地方寻找。
36.必报为什么要把调用一次的返回值的函数赋值给一个变量，是因为，返回值那个函数可以重复调用，但是外层函数不可以再次调用，否则就会再次初始化变量，就不可以缓存数据了，就跟全局的变量诶隐私修改一样。
6.1移动app06====================================================
1.关于子绝父相，相对定位的的是离她最近的有position的祖先元素。使用如果
2.使用max-width：1170px；意思是在页面在超出1170px前，宽度可变，是没有滚动条的。
3.@media screen and（min-width=1200px）
4.border-color: red transparent yellow pink; border-width: 10px; ----使用伪元素，不需要占用文档流。
5.为什么不直接在body下面添加属性overlflowhidden，在ipnone，失效，最好的方法就是在body下面建立一个div为index.
6.bootstrap:功能：前端框架，jq偏向于js，bootstrap偏向于css，提前写好了常用的样式，做成组件。原理：使用----使用方法：使用bt3，bootstrap最本质的是响应式布局，在相应式布局常用在移动开发，但是移动开发不是必须使用bootstrap，打开boot文件，找到默认的文件夹，copy出来，在demo中引入进来link文件，设置一个盒子抱着ul的模板，最外层到最内层，都是使用bootstrap提前写好的类名，直接在合适的地方添加类名就可以，最红要的一个是记住里面都有什么类名。----相同的结构不分标签名，只要要是类名给到位，一个简单的样式就出现了。---另一个钟用法是咋一个标签上使用多个类名，直接就尅实现多个样式的添加。评价：只是便捷开发一个相对简单的样式----一个很神奇的一点，就是类名的公用型，直接使用了类名在js文件中去处理一大堆的不一样的标签。----新的特点：既可以使用jquery来编写js文件，也可以只是用css样式，不需要添加jq插件。
7.bootstrap的类名与样式一一对应，通过图片与类名对应的方式，还有类名的组成规则。
8.制作---测试---上线----运行在用户环境为生产，运行在ide为开发环境。
9.cdn内容分发网络，根据网络ip，访问距离ip最近的这个网络路劲提供的文件，一个例子，在多个网站，多个页面访问的是同一个请求的文件，如果第一次没有访问过，就在最近的地址找到该文件，不会去找源文件，如果使用过，直接对应前一次的该文件缓存。目的是加速。提高网页的相应速度。
10.ie浏览器的怪异模式，不规范就导致渲染不出来，但是同时还不是任何一种渲染版本<meta http-equiv="X-UA-Compatible" content="IE=edge">这是兼容处理，不会进入怪异，进去边界浏览器，最新版本的浏览器。
11.[if It IE 9]----xxxxx------腻子程序，用来支持h5----[endif]-原生不支持响应式布局，ie8本来是不支持的，添加腻子程序，就是使用js变相的编译。还有一种是国产浏览器的壳浏览器。
12.bootstrap的使用所有的类名都要写在一个clss中，不可以分开写class。使用的时候，可以在原文件中使用查询，找到该样式或者原理，遇到陌生的类名，可以去用一用，另一种用法，在一个标签内部使用另一个具有明显语义的标签与类名，实现副标题，实现引用文件都是这样使用。列表使用的频次是最高的，如果使用普通的css，样式还是有点，list-unstyled就没有了样式了。list-inline,在一行上显示，table的类名就是设置在table中，必须设置thead与tbody，设置好类名皆可以改变tbody的样式，最好的是可以修改tr与td的类名，实现条纹户或者激活显示，或者单独的高亮。
13bootstrap内定义了很多的全局的样式，但是在使用的过程中会出现两种一种是直接就是标签与类名，另一种是必须要有一个模板，比如在表单这个css，form，内部添加div，类名为form-group，div内部添加input类名为form-control。围绕这个inputtext，周围可以设置很多的标签与属性，比如设置一个表单的左右与一个IAO标志，可以设置一个span，类名为相应的，各种标签使用想通过的类名form-control可以实现等宽。----单选多选，某些属性不写在语义标签中，写在div中，这样的设计也是为了不去影响到标准标签的使用，合理的理解，这个外层的div只是为了增加一个特别的样式。【inline是行内显示----control是对齐----success增加绿色高亮----info蓝色高亮----danger红色高亮----default白色----warning黄色高亮----primary主要深色蓝色---- 】
14，如果按钮是用input表单元素制作的就添加一个disable，如果input是使用a标签做的就在标签中使用disable类名。
15.栅格系统：bootstrap吧页面分为了12份，在class中使用col-sm-123456789101112；可以在横向占有这个单位数量的宽度。
16.所有的标签必须包括在container中，栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。下面就介绍一下 Bootstrap 栅格系统的工作原理：
“行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。通过“行（row）”在水平方向创建一组“列（column）”。
你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding。负值的 margin就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行。栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建。如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-md-* 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-lg-* 不存在， 也影响大屏幕设备。
17.关于在项目中使用css样式初始化，遇到的时候再去初始化，不要写多余的代码。
18.关于响应式开发就是用bootstrap的栅格默认12份，还有别的数量，一户可以修改，在通用的标签中类名设置多个类名，就可以在下关系应的默认屏幕与宽度现在不一样的大小。栅格的由来就这样实现了。
19.这里使用清除浮动使用一个单独的的盒子在需要清除的恩额个盒子的前面添加一个div设置clearfix，哈有一个属性，就是在响应式中哪个页面需要使用清除浮动可以动态的设置。
20.偏移使用col-lg-offset-n代表margin-left的值----嵌套在任何时候设置col-md-n代表的是父级被分成n与排序：使用占有的一部份另一个属性push补充另一部分。
21.xs-sm-md-lg----7912----visibility--hidden【使用在手机端的显示与隐藏】。
22.组件：u插件不是一回事，组件在css中，插件在js中，那些需要使用功能的必须有js代码。例子，模态框：点击一个按钮，按钮绑定的是一个弹出框，弹窗内部的代码可以自己去定制。
23.模态框：data-miss可以吧模态框消失data-toggle调用弹框，data-target指向某个div的id值为他的属性值的div。----组件：面包屑导航：指的是一个面条上边有很多小颗粒。----面板组件：内部是很多的p，h，table。
24.轮播图：遵循一定的结构，游标，轮播图内容，切换按钮，模板内部包括的属性与标签有很多，可以选择性的删除与修改，需要结合文档来进行。不管是哪一种组件与插件都需要使用class类名，减速带吗是基于jquery来实现的，选择性的使用jq代码来获得或者操作这些元素也是可以的。
25.如何定制性的修改默认的样式：1.使用优先级去覆盖（更多的类名串联或者id选择器）。2.使用外部字体，2.删除代码。4.调整大小与颜色，一方面默认的xssmmdlg前面的前缀可以是input，btn。默认的样式中宽度为100%，如果转为行内快元素，就可以使用三个调整
26.使用内部的margin为-15px，就可以抵消外部的padding15px；
27.使用模板，为了增加可读性，一般设置了xx-header，xx-body，xx-footer。这样的属性。
6.3项目开发01=======================================================
1.前两天开始命令行，后几天开始博学谷。最新的话题一定要知道。头条，积累社会认知。
2.git（linux的）使用命令行的模式进行的优点是快捷。命令行是一个软件，可以实现减免操作的而功能，最初的硬件上的都是命令行，命令悍软件是内切在window中的一个软件。
3.修改文件的最佳方式先备份，后修改。正确无误后添加在master中。
4.六个人自荐进行写作开发，leader给了代码与任务，一定时间完成，人工的模式就很麻烦，使用版本控制工具，最好。刚开始是1.0.来了人后1.0.1，还留着，张三李四合作做一个，工作自荐相互依赖，需要有一个衔接，把代码提交到版本控制工具中，另一个恩在mastaer中下载好代码，子级去修改，版本控制区修改master中的主干，最开始是本地版本控制工具，p个人的修改，后来又合作的情况，单独额一台电脑，远程发布，本子上也是一个版本控制，----因为工具不知道那些事有效代码，解决的方式就是程序员彼此的修改协商，去整合不断上传最新，下载最新集中开发。一个是文件版本多，一个是公用一个服务器，还有必须联网----诞生了分布式版本控制，登录式远程仓库，不是单纯的依赖远程，下载一个初始的版本在本机，修改之后完毕了，可以上传，但是他人还要在里面下载最新本版，每个人都有一套有日志的代码，但是当服务器宕机了，每个人都有代码在备份，安全性为100%。完美，重点按照这种模式加了备份与日志的特点。git的新分支，内部有一套算法，可以吧有差异的文件去合并。
5.对于本地仓库有三个工作区域：1.工作目录，在本地新创键的目录与文件，2.缓存区，提交上去的目录会被git记录日志，3本地仓库，这里的最终版本会被提交到远程仓库。
6.使用git之前都有独立的账号，两项信息，首先配置用户名登录与邮箱【消息】。然后初始化，在一个文件夹内部建立git，之后查询git状态，是个状态未追踪【新建的文件与文件夹】，----把工作中的目录添加到缓存区【git add *|单个|a1 a2 a3 a4这里都是未跟踪文件】----把暂存区的文件提交到-本地仓库【git commit -m ”备注信息“ （这里是路径）？----
7.绿色表示缓存区的文件，每一次提交就会出现一个黄色的命令行，红色的代表还没有被跟踪。凡是在这里提交的问价都丢不了了。新建的红色未跟踪，修改的红色未已修改未缓存。
8.git目录里面的东西缓存着所有的提交的文件，内部问价是被压缩的格式，打不开，直接删除这个文件就会死保存的文件全部丢失。
6.4git02===========================
1.数据通过协议去链接数据库，两种协议，telnet，不加密，ssh，加密，使用公钥，使用密码登录-客户端发送请求，服务器一对公钥私，把你的公钥给服务器，i自己拿着是要。
2.开发的分支策略，分子可以建立很多分子，但是master不轻易动，甚至，爱上线后，稳定才可以上去master。
3.管理员负责服务器中代码的合并，我们的工作赛给他代码，服务器中的分子名，跟自己本地的主干名一致，管理员在我上传的服务器分支中抽取我的代码，不合格就回滚。
4.git clone下载下来远程的仓库资源，现在下来后，进入该文件夹，这时可能有多个分支，并且只有一个master可以操作绿色，创建一个分支，对应的，创建一个与远程分支一个名字的本地分支，把那个同名的分支去合并。然后就可以进行pull或者merge，merge可以用在当前   
6.6项目01===========================================================
1。广告的发布，有点击与查看，每次有10-20的费用。
1.1公司的
1.2经过几个月，项目文件分别是smfox-build（后端的api支持项目，测试在这里测试）--smfox-api（后端的制作接口）--smfox-doc（给前端使用调接口说明）。
  ui的劳动成果是psd，
  前端的成果就是
   前端的劳动成果（整套页面的）
1.3在一个实际主机中安装阿帕奇，配置多个虚拟主机，分别存储多个服务器，节省成本。这是测试简单，在上线后，一个项目资源最少部署一台服务器，甚至减压会配置更多。
1.4配置环境：
2.现在都有云主机，早起的开发都是自己买设备，全天开机组一个机房，上线之前都是部署在低端服务器中至少一个前端项目与后端api-doc三个。
3.#Include conf/extra/httpd-vhosts.conf（499）----httpd-vhost（留三行）：e:/mybxg/test--e:/mybxg/a1--e:/mybxg/a2--e:/mybxg/a3(后面加上名字与域名api、www、doc、test)----window，driver，etc，hosts：127.0.0.1  所有的虚拟主机地址跟在这后面。-------其中每一个页面设置index.html------（部署上线）
3.1（开始部署项目到github）-----git网上资源-----修改文件目录，把大象装进冰箱，三部。
3.2.（httpd-conf）134行142行149行去掉#。-----
3.3（数据库初始化--研发经理在做）新建mybxg----打开在mybxg上新建bxg，unicode与utf-8----吧数据库代码粘贴过去----点击表刷新----在api中的database打开，取消密码与路径查看----
md5就是用来加密的，是单向加密
3.4开发环境完成后，测试，测试完成之后从测试环境进入生产环境上线项目------每人必须熟悉这个流程
4.买了域名，www.----api----等这些自己去配置，都是自己的。
5.技术岗完全看能力，不要想多了。孩子！！！！
6.后端渲染：php页面，后端制作文档之后直接生成静态页面；前端渲染，写好魔板，利用后端的文档，去在自己的页面去添加。
7.php页面在浏览器中不可以直接获取，请求一个php页面的数据验证，必须使用插件，使用反向代理，在地址栏输入路径就可以测试，在插件中输入数据，运行后就可以看到结果如何了。
8。路径--post--body---复制data--添加数据---运行---测试结果的状态值。
9.登录接口先要执行一遍，用来滚一遍session，其次去寻找所属的键值对去验证。
10.在上线的根目录中，应该有多个文件夹，比如，index首页数据，user用户数据，assets组件库。
11.vhost文件中命令：/api http://api.studyit.com.就是成家一个映射，使用/api可以代替跨域，这是使用阿帕奇设置来实现跨域。也可以通过jsonp实现，在jq插件中的ajax的使用需要有对应的属性l，data：$("loginForm").serialize();---获取的是form表单中的所有的具有name属性的input标签。
12.使用apqi中的映射来代替一个其他域名下的文件，社会映射必须包括在操作页面的那个模块中，他模块不起作用。
13.success：函数内部第一判断data的状态值是否是200，在if判断中，讲页面条状到个人信息location.href="xxxx";
14.登录的时候，传入账号与密码的时候，后台记录session，同时在本地的cookie中存储一个sessionId，这个使用在用户退出登录的时候也可以使用。
15.当你说调用一个接口，或者要跟后台进行一次交互，就要使用api，就要使用ajax。不管是jq，还是原生，都找data的条件下，实现了函数内部动作的实现，一种是验证状态值的状态吗，另一种是吧数据添加在dom树上。
16.set-cookie在第一次请求的时候开始设置，并且把这个保存在本地，在退出的时候吧这个sessionid传给后台，后台验证，看起来没有参数的传递，实际上，就是cookid的传递。
17.映射有两个，一个是修改index，另一个是实现跨域/xxx代替某个域名。
6.7项目开发02-----------------------------------------------------------------------------------------------------------
1.使用index。php这样的后台是作为路由，对整个网站的页面的跳转都进行链接。起到中心站的作用。
2.url地址跟目录地址不是一定相吻合的，前端设置链接不一定知道文件的具体位置，通过api文档可以试想页面跳转，但是不会暴露文件的文件名。
3.使用cookie来存储不严谨的数据缓存与临时信息，避免多次验证，session在后台通过每一台计算机的cookieid来判断状态，前端下一次请求又可以通过已有的id来判断。
4.wamp是有window先的apache服务器配置文件库与域名的映射，还包括一个默认指向那个文件显示与跨域的另一个域名的占位符，mysql可以打开数据库，通过语句操作数据库命令，或者通过可视化操作界面，实现数据的增删改查。php可以实现也网站的交互，最主要是实现对php文件的解析。
5.前端使用iframe可以实现模拟后台在当前页面实现多个页面的跳转，当前页面的固定布局不改变。使用ajax使用后端的交互局部刷新。
6.xht.open(type,url)----始终状态，一个后端地址
7.状态维护：客户端与服务端的状态维护，因为http协议无状态，第一次请求与第二次请求与响应之间没有关系，在淘宝买了商品交钱，再买 的时候还要登录吗？方案，就是cookie，输入账号与密码与登录成功状态，存储到cookie中，发送到后台，后台验证，每次跳转同域名下，都会把这个cookieid传给客户端，在客户端就可以不用再次登录，缺点就是1，安全隐患，可以被伪造，2.存储为4k。cookie一种是会话，关闭丢失，一种是持久，有效期前存在文件中----为了解决cookie的缺点，使用第一次cookie数据验证通过后存在session中，生成sessionid唯一，并关联session关联的数据，这是登陆成功后的状态，服务器随机生成不同用户不相同，是一个字符串，放在set-cookie响应头中，第一次响应结束结束，第二次切换网页，请求带着cookieid发到后台，后台在唯一的id上执行响应，缺点：1.session存储在服务器中的内存中，session对应每一个用户，session太多就hi卡服务器，把session单独的放在独立的设备处理，别的设备区共享session中的id，服务器区处理响应。 【一个例外，没有登录却可以操作部分登陆后才可以执行的操作：未登录前创建临时，登陆后可以替换】，返回的sessionid，不会被存储在文件，只在会话cookie中。退出的时候服务器销毁了sessionid，下一次登录有创建 了一个新的sessionid。如果浏览器把cookie禁止了，解决方案就是把sessionid放在url参数，服务器通过参数实现cookie的作用。

8.风格不优雅，模块化是一种写代码的方式，是将来的趋势，编程有自己的进步，最初的开始，是用来实现简单的验证，就可以写一些简单的代码，不够严谨，后来发现除了这样，还衍生了dom与ajax，现在的需求高，写法灵活，对程序的维护性有影响，demo的时候我们的代码是这样的，简单，全局变量，单个功能，后来出现团队协作，变量名的冲突时最常见的，就出现了面向对象（thsi）从一定程度上解决变量名冲突，不能从根本上解决问题。----后来出现了命名空间，以下划线开头，后面跟上对象，对象，对象，对象，对象，对象。

9.很常见的一个问题，多个js文件的变量连接，或导致文件依赖--一个是命名冲突--出现了模块化开发，之前可能遇到过，函数自执行，一个文件中放这样的一个形式，原理是函数自执行后变量被释放。自执行可以使用传入一个参数，参数的其中一个属性在该函数中被赋值，在另一个函数中，使用这个参数的那个属性，不会被释放，在全局访问这个对象的内部属性，都还在。----另一种方法，使用同样的名字但是在内部，使用了return来返回不一样的值，每次各自的下方调用，都是最近的那个值，而且与上边类似，都会被添加新的属性与值。

10.由于各大厂商的开发不贵发，坏形成了浏览器端与服务器端的模块化开发。js运行在浏览器中的js渲染引擎，在服务器端也可以运行，就是node。js，最大区别就是咩有dom就css动画，可以做什么，可以试想文件的挑选与处理。js引擎v8，两种浏览器模块化的方案amd，cmd，是两个规范，与ECMAScript的规范一样，js实现了ECMAScript，不可以直接使用，需要使用开发，我们使用框架来实现amd【requirejs用来实现ajax】+cmd【seajs目前不怎么用】。在服务端的规范就是commonJS，实现规范的语言就是nodejs。浏览器端要实现网络需求，下载与运行，服务器端不需要联网，是同步加载。

11.使用requestsjs引入两个问价，一个是mainjs，一个是requestjs文件，为实现模块化，我们去隔离该隔离的也要关联该关联的，每一个模块都可以设置同名并且在同一个页面加载后不会冲突，但是我们关联也需要，该怎么办？规定的在一个页面中每个js中格式必须包含在define（function（）{}）中，这实现了沙箱，那么关联怎么办，在该文件中define的参数为多个并为数组类型，第二个参数为函数，函数的参数形参为之前数组的值，形参的获取到的是其他define的return值，使用闭包把该顶级对象返回给其他的define，注意的一点是，在return的返回值的函数内部，必须把所有要回调的变量设置在回调函数的顶级对象下面建立依赖关系。----当路径长度太长的话需要在参数中数组写上很多，一个好的方法是，在开头文件中，requestjs（{对象键值对}）有返回值的写在前边没有返回值的要写在参数的后面。

12.项目创建完毕需要在本地仓库初始化，获取远程地址，在github上创建一个空的仓库，获取仓库的地址，在本地先remote，再push-u，下一次使用直接使用pull与push就可以，但还如果出现问题，必须要删除原点origin，命令为git remote remove origin。

12.库与框架的区别，库是方法的集合api更多，框架是基础功能多，api少，都是js扩展，具有共同性。 

13.插件只要存在define就是一个标准话插件模块。 
6.9项目03======================
1.博蓄贾项目，后台管理系统dim，物流管理系统，这些都有，都是维护数据的，通过前端的链接来调用后台的数据处理页面，外挂就是破解漏洞，打补丁，利用系统的漏洞，游戏公司利息丢失，数据监控，是运营人员使用。任何运营公司，都是有多个项目组成，以淘宝为例，有商家页面，还有卖家页面，负责管理的是顶级管理运营，可以开发权限与关闭，除此，还有数据分析与统计，这个数据是核心人员来看。还有物流就是也是单独的维护，跟商家那个数据不是一回事。一个真实的项目有多个子系统，来支持一个项目的运营，至少一个后台管理。

2.移动端没有兼容性，都是webkit，pc端兼容问题，尤其是淘宝这种，还有app端，三个项目实现一个目的，都是在玉带一个新的场景，就去查询api然后去专精一个方向。然后学会去技术血型去摄影，前端bootstrap+requeir。js+jquery+php。前后端分离，后端只做接口，前端只调用接口，数据库交给运营。

3.使用哪个框架与库，都需要使用js为基础，实现你的任务需要查询与学习教程与api，就可以实现自己的操作界面，与交互的填充数据。不要拿你的短处与别人的场次去比。洗澡的时候没想好顺序就没法洗，九个编程一样。

4.银行的操作有操作记录，后台人员有记录，不会这样做，理论上，有这个权限的人而已做到。不可以把安全限制在不敢，只可以限定在不可修改，只读，不可改状态。

5.arttemplate：模板引擎，页面的渲染使用模板，语法，api， 在script标签中使用{{}}这样的模板，在div中或者ul中设置变量，与流程控制语句，使用对象数据，再接再模板中国填充就好。另一种方法是，使用模板的第一次，转化字符串，为一个函数，在使用render函数，转化为一个html字符串。使用的是两种用法，一个是temolate函数，传入模板参数+data数据参数。（之前的用法是字符串格式的模板，需要两次函数处理，才可以添加到container的div中）另一种用法是字符串的模式，使用render函数，传入模板与数据，天交代摸个div中。

6.这个也是支持require的，模板引擎中有define函数，可以像模块化那样实现全部变量隔离，选择性的文件依赖。template。complite----
template.render(模板为字符串两个搭配)----模板为标准格式，直接就是template（IdTpl，idTplData）----直接使用
6.详细信息的列表制作  

7.菜单栏的切换，页面变化

8.模态框：显示详细信息。在模板中使用boot组件。

9.模板没有渲染完成，根据时间队列的异步原则，就会产生空的模板，应该放在ajax中，在时间队列中一起执行。

10.替换一个字符串的三种方法，aplit，jion，或者replace（正则，替换内容）

11.广告的使用，定位信息会暴露自己的行动轨迹，理财软件会暴露自己的银行卡号，身份证，真实姓名，app注册会暴露自己的手机号码，游戏会暴露自己的空余时间，网购会暴露自己的行为习惯与详细信息。腾讯与阿里会通过大数据，精确地人肉到每一个互联网的人。

11.当格式为# +类名的文档不会被转义，不加上#就会转义。 

12.一个连接两个
6.10项目开发04====================
1.添加与编辑，当公用一个数据库的数据时，应该在两个页面设置一个切换效果。使用公共页面，部分改变，ajax大多数时间都是重复的代码，可以在一个js文件中，对于请求数据相同的情况，使用封装在一个函数中，把它

2.当使用模板后，需要在模板下面才可以操作基于模板的加载的语句。否则会出现动态添加与异步加载的时间队列的问题。

3.
6.12项目06=====================================
1.金融，地产，IT。互联网公司互联公司一直在缺用户，一旦开始形成用户粘性，就可以赚钱，就跟qq的盈利最初开始一旦形成了平台，对外的接口，就可以挣钱了，所谓的领域性的电商，靠单一性品牌，还有卖服务的比如账号交易，会员充值----剩下的就是业务相关，写字靠打赏也可以，技术领先发展，支持软件的运行，前端hi其中一个关键点，用到了技术血型，传统的就是jquery，现在的血型angular与vue，使用aps单页应用程序，在一个页面中，使用局部更新，使用ajax的框架，基于vue与angular来实现像掌游宝的功能。
1.1为什么使用插件，方便快捷，稳定。
2.使用插件的方法：1.引入一个外部js文件，2.使用引入的插件中的api，3.对照文档。
3.模块化，requirejs的职责，思想是：性能优化主要是后端来做，前端的性能优化就是w3c标准。
4.使用与理解，内部原理jq的实例化，插件的底层原理，看代码，看思路，熟读唐诗三百遍，不会做诗也会吟···
5.参数的作用就是用来接收未知变量，处理后，通过return来公开成员。这是模块化的有无参数的用法，也是公开成员使用return的原因，也是闭包 的使用原理之一。
6.一个正式的运营项目不止一个，项目的其中之一就是
7.目前的互联刚的盈利模式，qq随着用户量增加，不赚钱就买设备，差点卖了，没卖掉。
8.目前就是前后端分离的开发节奏，举一个不分离的例子，在php页面中写出来静态页面，直接就绑定了，前端拿到的不分离项目，就是后端文件了，工作就复杂了，后端安装好环境，在这个基础上做一个调试，php不去改变，你去改变html的样式与行为。这样的有但是很难受，不利于前端开展工作----分离之后就不需要关注后端了，只需要接口来拿数据自己制作所有的前端，不需要后端IDE实现自己 的代码运行，所有交互要掌握精髓。
9.插件与组件与框架与类库的使用都是----基于jquery+使用模板引擎+再去使用jq插件实现行为（跳转，发出请求ajax，）+url的api请求或后端数据获取
10.技术层面就是使用模块化，
11.使用baiduapistroe参照文档可以实现jq的跨域获取参数。
12.使用upload插件，功能：使用：文档----使用jq，使用js插件，页面简单而少的标签，可操作的标签，必须有name，js文件中，使用jq操作元素，调用upload函数，在参数中中设置对象的格式包括url与其他的映射。可以定制样式，注意冲突，或者去掉link。
13.   ajax的异步操作内部去添加模板，或者dom操作。
14.上传文件失败，是因为后台的php的配置有问题，并不是文件有问题。
15.使用api的查询方式最好的就是官方文档，最明显的就是，一种是使用框架与插件的方式，在js 代码的json格式中修改属性与值，另一种是通过修改类名来实现样式的改变。
16.使用require的define的参数开头，第一个参数的顺序是又返回值的在前，没有返回值的在后，第二个参数的顺序是，按照前一个参数的顺序设置。
17.理解使用requirejs实现模块化编程，可以解决的问题是
18.插件：账号密码验证插件，模态框的boot，富文本插件，表单，日期表，三级联动自己制作。
19数据类型，算法分类，就以课程为例：
前端
    |---------html
    |---------css
                            |------------bootstrap
                            |------------
    |---------javascript
                            |---------闭包
                                                 |------------return
                            |---------面向对象编程
                                                 |------------模块化开发
 20.在数据库可视化操作界面中使用的方法是，主键是唯一的，主键的值不可被重复。
 6.13项目07======================
 1.后台的json格式传到前台的格式，会被datatype的值定向的修改返回值，所以不可省略，省略的话，就是text。自己返回的对象，默认情况使用eval与jsonparse（），方法来解码。在新的里面转化为字符串是jsonstringfy（）；
 2.updata course set ca_name = ‘java’where ‘ca_name’= ‘23’；
 3.三级两级联动，一级目录被选择二级目录才出现，在每次切换下拉列表的时候都要使用ajax，就是最明显的一个交互了。
 4.添加与修改是不一样的a跳转但是在操作页面是相同的。每次跳转过去都要进行ajax请求。
 5.项目开始，给了你一静态的页面，在这个页面上，使用到了requirejs，jq，表单插件，表单文档提示，模仿ajax，自己有有个submitajax，对按钮的dom操作，对返回的数据查询，注意在ajax内部去填充页面缺省区域。
 7.使用flash的swf格式可以裁剪上传的图片。
 8.为了预防多次添加的bug，或者是多次执行当前函数，就像遍历前的清空一样，在函数调用之前，再一次设置null。定时器，创建元素，执行裁切，都要提前判断。
 9.前后端分离以url地址隔离，前端技术血型，使用的是requirejs框架，基础性模块化开发，提供了写代码的规则，ui层面使用的是bootstrap框架，还有jquery主要使用相关api与ajax，还有基于jquerty的插件，还有arttemplate，还有基于ajax的调用后台接口，-----1.dom标签绑定事件，也有可能页面首次加载也要触发ajax，比如详情页进来就有信息，2.触发发送有无参数的ajaxjson或jsonp--3.解析数据，两个钟方式，字符串拼接或者模板函数---4.功能就是增删改查基于数据库，区别在于业务相关功能，按钮的布置与技术关系逻辑性。=====后端技术血型：php与MySQL，php框架thinkphp。----前后端的状态保持就是session与cookie，多多理解。以上的只是需要在项目中一一领悟，尽力做出来。
 
 6.15angular01----------------------------------
 1.mvc之前的更加侧重后端，很长的一段时间里前端没有mvc，angular创建了前端的额mvc。
 2.相比于jq的类库，angular是一个框架，框架更加的综合，包含了各式各样的类库。jq使用dom作为驱动，首先后去dom元素，其次才是操作，angular多数情况不操作dom，更多的是绑定数据，在对象在中使用逻辑实现绑定操作。那么跟vue的却别在哪里？
 3.类似的less与sass；jquery与zepto；git与svn；angular与vue与react是三大主流的。本质上都是一个js文件，在页面获得yigejs文件，过得方式都是一样的，首先是通过官网的方式获得，其次是通过github获取，最后还可以通过npm的方式去下载安装。
 
4.使用一个js文件，可以在自己的相对路径使用，也可以使用url的绝对路径，可以死网络地址，也可以是自己的电脑端额地址。

5.分工明确，谁适合做什么就安排就去什么，分工的目的就是效率，工作的内容就是对员工进行分工，这样做的唯一目的就是，可以使得通过效率得到提升，在开服模式中，不适用mvc也可以处理，使用js处理前段后端数据连接，但是使用angular可以分工更明确，唯一的目的就是提升开发的效率。

6.mcv就是model构建数据模型，view可以展示后端数据，controller是负责连接对应的前后端。后面的mvvm，mvp等都是mvc框架的衍生。

7.requirejs与seajs都可以起到模块化的思想，angular与vue与react都是思想这个实现，只是实现的方式不一样，实战上不一样，angular是以模块的方式限制代码的编辑的。

8.anlularjs的基本结构，
首先制定一个应用，其次通过一个属性来指定胡这说是绑定一个应用，接着使用一个ng-app固定属性来设置一个生态的最外层边界，----接着内部使用script来完成逻辑，按着模块的形式组织，映入angular文件就会创建一个全局的angular对象，其中的和兴方法就是module，【var app=angular.module】这个方法需要两个参数，第一个是模块的名称名称与html中的标签的属性的值一一对应，第二个是依赖，第二个必须是数组，哪怕是空数组。----对三个mvc的名臣精心创建，三个和兴的方法，都可以直接被调用，这个方法【app.controller('  '),[  ]】,第一个参数是控制器的名字，第二个是依赖
App.controller('DemoCtrl',['$scope',function($scope){xxxxxx}]);----进入开发环境了，需要注意使用的电脑的盘符，专门用来管理代码与网站，这个网站下班就是子级的代码文件夹，知道分类管理，申明代码在申明地方存放。
9.controller可以多吃调用，第二次调用依旧是控制前名字，数组内部顶级对象scope与scopeEric参数的函数，函数体内是设置view的内容的对象们。

10.使用angular的指令是关键，就像原始的普通标签的属性src=“”，这样，在angular的生态环境下也是模拟原始生态设置了专属的属性与值，angularjs来解析这指令，常见的手势内置的指令：都是以ng-开头后面是【if，src，href，class，include，disabled，app，controller，show，hide，readonly，checked，】还有一种是自定义定制的。定制的方法是：

11.ng-app，至少有一个，如果需要有多个环境，必须并列不可以嵌套，一般是写在body或者html中，ng-app=“xxx”，用来创建一个生态环境。----ng-controller，可以有多个，也不可以嵌套，设置后必须在js中进行创建，否则就是报错。在其起名的时候需要注意首字母的大小写，不管怎么写都可以被识别只是，一种可读性的规范。----ng-show，值为true或者false，可以在json对象中设置当前的值，改变他的状态。或者可以使用隐式转化，使用0与1，设置当前的true与false。----ng-if，设置当前节点是否存在，对比show，不同点在于是否在dom树上显示。能都获取。

12.使用ng-标准属性这样的形式，实现的是浏览器的两次请求，第一次请求获取的是变量的形式，无法识别，第二次才可以是angular生态环境进行解析的请求，所有的用到变量的环境下，都要使用ng-来加强。

13.单独的一个是ng-class，可以在值中使用对象的形式，如果对象的键值对的值是布尔值，返回的就是某些类名，可以用来切换或者批量的改变类名来显示不一样的效果。一样的原理，使用布尔值来控制无值属性，是一个误区，它不管返回值是trye还是false都会触发效果，这里使用ng-disabled，或者ng-readonly都可以设置01来控制效果是否触发。使用的目的是是开发习惯与思维方式像吻合。

14.php中有一个路由命令，用来指向包含的所有文件，ng-include出不来的原因是浏览器的安全策略，一个是不可以主动地读取文件，另一个是不可以跨域读取文件。

15.实现一个公共部分的公用，有两个方式，一个是ng-include=“‘一个路径’”，页面有angular来解析这个属性与值，就可以实现公共部分的应用，另一个是使用php的include方法，把script，css，html放在一个文件中去读取。

16.在现实中，angular就是ng，因为一ng开头，出来内置的指令，还有一些自定义的指令，这就是集成的强大之处，肯定不可能是完美的，开发者可以根据自己的业务需求扩展自己的需求，是angular的核心知识点，浅层次的angularjs的指令很复杂，作为预科，为学习vue做准备。

17.使用自定义标签的方法是设置一个A属性，或者设置一个标签，E标签名就是我们在，C就是使用class值映射到名称上，还有一个是M，mark，在注释上使用，<--derivtive:mark-->概念的高大上比如数据绑定，就是一个填坑，闭包，就是暴露局部变量。

18.anguar的单向绑定是通过指令ng-bind绑定在标签，我们使用双括号是ng-bind的简写，实现的是单向的数据绑定，实现一个输入框完成后被提交到js中国显示到h3标签中，就是双向绑定，还有一点是，使用{{}}来代替bind就是绑定，但是使用{{}}较多，是因为可以多个绑定，会出现闪烁，使用指令ng-clock解决，原理是创建一个css。

19.ng-model可以吧input的数据绑定到模型上，使用花括号可以吧模型数据映射到标签的内部与外部。

20.使用ng-model双向数据的绑定，或者使用cick实现函数的绑定，两个的指向都对应到script的模型数据中，使用函数的参数为数据，或者参数为index。

6.16angular02=---------------------------------------

1.angular的作用域与函数的作用域类似，如果子级作用域没有设置某个变量，就会寻找父级的作用域中的同名变量。

2.使用控制器controller，如果只是使用scope来进行变量的绑定，那么久不需要使用别的，但是，如果要使用新的api（内置服务）来处理获取或者被设置的数据，就要在函数的参数中进行注入，注入之前，在数组中传入参数，或者，没有参入参数，在开发模式下可以实现为注入的服务，但是压缩之后，就无法识别了。

3.有两个filter，一个是对数据的处理方法，在|后面设置filter，另一种方法是filter方法（过滤器），这些都是函数，函数的特点之一就是使用。

6.18angular03=---------------------------------
1.因为angular的版本更新太快，导致很多方法在后续的版本中不可使用，所以就可以作为一个入门的vue的。

2.使用angular的ajax的参数的传递有个特殊的用法，使用get的方式穿的参数的方式是json格式的键值对，使用post的方法的话，使用的就是字符串的url的后缀，这是很奇特的一点，本来是医改互换的，打死需要记，在使用angular的跨域的时候，需要先进行配置，才可以传入读个蚕丝parmas，来实现，在配置的时候，用到两个参数，一个是xxxProviter，另一个是xxProviter.registor（）；

3.类似的，在commonjs的使用也用到了requirejs的config，在使用angular的时候，对于自定义的在基础的九种过滤器上，增加多个新的过滤器的特点就是，使用config，proviter，register。

4.在angular中，使用样式的改变，需要使用另一个库或者框架，如何在angular中使用jquery来实现样式的改变，在js中，可以通过$('选择器')[0]==angular.element.document.querySelector('xx')；当我们同引用了jquery与angular，如果可用就会使用angular》element来代替$,如果不可应，可以这样使用但是会成为一个原来的jqLite，是一个子集，不全但是基本功能有，一个animate是没有的。使用jquery也可以，会实现之前没有实现的效果，

5.jquery由两部分构成一部分是选择器它的返回值是一个jq对象，另一部分是api在对象下设置方法，在angular下，使用模拟jq，不支持选择器是因为返回值不是jq对象，虽然在anguler中可以支持jq，但是不建议一起使用，因为jq是基于dom，而angular是脱离dom操作，所以，jq倾向于样式与动画的静态，而angular在api对接更优秀。

6.路由：地址与程序（页面）的关联，映射，是一对一关系，SPA是single page APPlication的缩写，单页面应用的缩写，与多页面相对应，多页面的应用，多个功能对应着对个页面，整个网站都是在一个页面上进行的，为什么使用单页面应用？单页面可以去除公共类的请求，可以通过样式的改变来实现，非公共类的切换，而不是通过请求实现，这样在app 中使用即使不联网的时候也可以看见缓存支持的app。

7.实现页面的跳转，一个是使用最普遍的url的跳转，另一个是使用ajax，实现script中动态添加，还有一个是使用单页面通过锚点实现，使用window.onhashchange=function这样，实现，代码块的触发。hash哈希，就是对用的一个锚点#xxx，这样的形式使用switch分支判断，实现不一样的动态实现布局页面，但是也没有ajax请求。

8.hash = location.slice(num1,[num]?);实现截取第一个字符，返回之后的字符

9.bom：location表示的是文件信息，包括了hash，href---

10.var  xhr = new XMLHttpRequst();
    
    
11.在angular总使用单页面应用注意一：设置锚点在a标签，必须使用href=“#!xxx”第二：先创建生态，在创建config，绑定一个proviter，函数内部处理代码，proviter调用使用when来进行选择性判断，第一个参数是名字，要与标签中的href的值一一对应，第二个是模板或者模板地址，加载的内容不需要使用innerHTML，只要在标签中使用ng-view，就可以以了。路由的另外一个属性是controller属性，可以在接下俩的函数中直接使用之前的控制器语句与命令。比如添加一个参数到输入框中，  可以动态创建一个控制器，在{{}}中改变值。

12. 使用node.ls可以安装----npm install -g bower===bower的功能，一个是下载$ bower install jquery#1.9.1（可以没有版本号）一个是自动下载依赖文件（比如下载jquery.cookie）会下载下来两个问价，而且不可以直接unstallcookie文件因为依赖关系。bower下的命令（search，info，install，unstall）。

6.19angular04=----------------------------------
1.文件的目录结构要有常规的分类方法，不要使用零散的放置方式，index的问价为什么要放根目录下，思维了设置一个定位点，方便在单页面的实现，js与所有的src的实现可以统一调用。

2.angular的执行顺序，遇到angular之后就执行angular。涉及到一个原生class什么时候会被加载出错的问题。

3.一样的，当使用单页面实现，必须要使用的就是路由问价，config与when与otherwise，语句是核心。原理是switch语句。

4.分页面是一个完整的文档，我需要去掉除body的所有内容，或者不去除也可以被浏览器省略，但是这样的方法，加重了浏览器的任务与负担，类似的，度页面用用会用在公共的样式，也可以删掉，那么，三点以后就识别不来怎办，使用的而方法就是php的include，或者angular的include方法也可以。

5.网站有事为了防止链接被盗，会进行加密，就可以使用服务器的phpopenssl来进行服务器之间的数据获取，或者是使用插件来实现，但是用户不一定会有插件，所以，服务器的方法还是比较有用。

6.前端处理当前时间是客户端的时间，后端处理的时间是服务器的当前时间。有些东西，前端实现起来比较难得话，可以请后端去制作，可能实现起来更加合理完美。知晓一些后端的技术，是很必要的。

7.http的方法用来获取后台的json数据，用来填充模板，相对的config方法的作用就是用来获取本地的页面用来当做底板
$http({
        url:'./pages/xxx.php';
        method: 'get',
        params:{key: value}
}).then(function(res){
        
})
----------------------------------


8.php的常见了几个应用的命令。比如，获取一个跨域的api----file_get_contents('url');----获得时间:time()这是获取时间计数的方法。tostringtime(nday),获取的是当前时间前后的几个时间点的计数点。后端使用date（格式，time（）），就可以编译出来当前时间与格式。

6.21angularjs05-=-----------------------------------------------------------------------

1.对比jq的ajax，angular中的ajax请求对于模板的处理hi通过抽取一个html页面的结构来填充的。

2.跨域使用后端文件获取的原理，跨域如果是从浏览器这里发出，会被拦截，但是，如果在后端穿出，再前端去抽取识别揽过来，这样就不会被浏览器发现跨域，还有主动获取文件。

2.var_dump(xxx)----可以输出复杂或全部类型的数据，echo只可以输出简单类型。

3.json_encode编码用来把对象的格式，转化为字符串，然后传递，而json_decode解码用来把一个字符串转化为一个对象数组格式。

4.通过php的语句可以获取除了固定网站免费给的那些api，或者不对外开发的数据。

5.布尔值的开头语结尾，只要中间的ajax到异步不跟他冲突，只要在顺序上执行，前面的布尔值，尾部被改变就一定是中间的处理部分结束之后才会被触发。尾部的改变必须在ajax的异步中。

5。js文件的分诶，第一个文件，是配置文件，也就是入口文件，第二个文件是处理文件，比如多有的控制器controllers这样的，还有一个是，公共类的分类，一个servicesjs文件，

6.关于抽取公共类，如果多个页面用到了同一套处理方法，比如设计，比如js的处理逻辑，重复的js如果使用了多个依赖，就可以吧这个模块独立出去，然后封装在一个控制器中，然后就想填充页面的模式，吧封装好的模块也依赖进去，就不需要使用任何其他的多余依赖，这样多层嵌套在代码上不一定速度最快的，但是是单页面js代码看起来最少的，所谓模块化。只是形体上像是而已。

6.需要注意在标签中不适用驼峰的名字，在变量中占整个，不是哟下划线的。 

7.gulp独立于模块化开发。开发过程讲究可读性，存在很多注释与换行，另一个开发问题hi文件太多，引入太多。后续的工作就是使用gulp实现压缩与合并。

8.安装gulp全局----安装某个目录中本地gulp文件，----床架一个dulpfile.js文件来设置本地构建语法。创建一个依赖使用require（xx）一个依赖，就是gulp，其次调用task方法，参数是自定义名字，一个回调函数。内部函数可以被窗口执行出来代码，这样的js文件可不是被浏览器渲染的，而是在后台环境中被实现的。

9.过滤器：{name|uppercase|limitTO:4|lowercase}===>得到一个呗处理的name，js中两个||表示或逻辑运算，类似的|，在gulp中使用pipe（管道）来实现|的作用，用来连接多个过滤器、

10.报错warning还可以执行，但还是error就是真的错了执行不下去了。

11.共同点：angularjs、requirejs、打包工具gulp，webpack，grunt，都是依赖方式。

12.理解的层面，在jquery中的链式编程，点后面的方法，只要不遇到新的dom对象，就一直不会改变this。在使用angular的控制器，还有打包工具的顶级对象的时候也是这样，可以使用连死编程的方法，但是，使用顶级对象的方法就该是最顶级的，而不是你映入的某个高级对象，要分清楚。原理层面，就是每次调用这个函数返回的是处理后的原始对象，哇咔咔。

13.常用的task包含着（watch，src，pipe，dest）一次性调用一套。js文件也可以被压缩，不过不一样的地方是，js被压缩后所有的变量都被改为了一个字母根本就读不懂了。task----src（参数为*.js）----pipe----uglify----concat（参数为处理后最终的文件名）====处理图片：首先获得处理的图片的文件夹中的全部*,如果有多个文件夹，放在数组中，第二个参数是对象，base：./或者./xxx，这个地方的路径会被切下去，只压缩后面的文件夹，分开存放在接下来使用的存储路劲中分开存放，pipe管道。

14.当默认的属性不可以实现，基本上也是所有恶属性都有一个参数，或者是第二个参数来说实现定制的效果。比如压缩html的属性，压缩空白符，压缩注释，分别对应的是collcasewhitespace，removecommts，分别对应的是取消空白与取消注释。

15.解释缓存的好处，当浏览器据欧默认的静态资源的功能，通过和缓存静态资源，（html，js，css）可以提升范根的速度，----首先，在访问一个页面的时候，进行dom的解析，当解析到src或者href 时候，会再次发起一个请求，并且会将求情来的结果，处在本地，当用户再次访问的时候，根据条件，直读取本地缓存文件。比如，同一个域名下，a页面与b页面都会访问一个同一个地址的img的src，就会出现相同。----类似的，如果改版出现新版的路径没有改变，就会出现新的路劲被旧得路径代替。解决的办法就是在路劲的后面跟上自定义的参数一般是时间值，但是想要对改变的css重新加载，但是没有bug的css还要继续保持缓存，----最合适的就是md5加密，特点就是，相同的文件名，文件没有改变md5的值不改变，文件名不改变，文件内容改，md5只也不一样。使用rev【这是gulp自带的版本工具】---需要注意的是，所有的内部执行都有一个顺序性问题。

16.一个是自动添加私有前缀，另一个是设置
替换路劲还有一个是替换html中的script与link的引入userf方法，直接实现了concat的合并操作，哈可以在HTML中设置build：css urlxxxxxbuildend，来实现某个区间的文件的合并。还有一个是gulp-if，这个函数两个参数了，一个是正则的匹配，另一个是回调另一个过滤器。

17.神烦：既可以实现images的实现，又可以说实现css，还可以实现js，但是有一个问题，只有js的可以使用的一个是userf。

18.线创建一个顶级的对象dulp----建立依赖之后，创建一个task方便在dos中调用，在task的函数中设置各种要处理的命令方法。首先呀获取一个文件的路径，明确需求，要转化的是less，还是html，还是js，之后要做的是压缩？添加后缀名字？设置好被替换的路径的代替名字，存储在一个package文件中？rename重新命名？设置到要被保存在的文件夹的位置替换路径？html中userf来合并设置好html中的build标记。----图片的出来，先压缩，后设置版本，最后存在文件中，补充的是保存记录，先后要进行两次保存，就是文件已文件的修改信息。

19.处理js的专有的是useref等效于concat--uglify压缩等效于cssmin或htmlmin。

20.一个处理的流程是，js，htmlcss分别处理后放在一个地点，而其他文件不需要处理那么多，直接使用src与dest阿里转义就可以、最后要做的是collcoter进行替换路劲，这个替换就是改变html与css的替换rev（）直接使用两个零换 就可以，但是在js在那个使用rev替换必须要在和html在那个制作标记。

21。变通的做法，把所有的task依赖到一个task上。

6.22nodejs01---------------------------------------
1.如果出现node安装后，出不来版本与npm的命令效果，就是环境变量影响的。

2.commonjs标准中的require的作用有点像script的作用。

3.es3,5,6分别是版本号，之前用的是es5，现在在es6有羽凡的改进，在es6中，nodejs中用到大量的es6语法，相反的在浏览器中使用es6反而比较少，在浏览器中高版本支持es6，低版本基本少用es6，一般是在开发中使用es6，gulp再去转化为es5.es6要熟悉，但是在node中，es6是绝对完美支持的。

4.作用域：本身任何{}中的语句都是作用域，不可被外部访问，es5es6都不支持块级作用域。

6.se6：var 弱类型声明变量----let强类型声明变量----const强类型声明常量。

7.出现错误知道在哪里找到错误，一个是块作用域，一个是强声明。lei的特点是取消了var的变量提升直接报错，也取消了无视块级作用域的特点直接报错。

8.解构式赋值：变量放在一个数组中，值也放在一个数组中。分别是一一对应的关系。

9.如果左侧的数组中的值不可以与右侧数组中的值进行对应，就出现变量为undefined。形式是可变的但是遵循的规律是始终是索引的一一对应。优先使用后面的数组的值，但是后面的数组不给的值话，就使用前一个数组使用的值。

10.返回一个json字符串后，很自然的第一件事情就是转化或者是压缩。在json对象中，还有一大堆的而外属性与方法没有被我们使用，却要在处理的时候被处理，加重了负担，使用字符串的方式，可以减少很多的方法。

11.es5中，拼接字符串是使用单双引号与加好来实现，在es6中使用的是反引号，就是一号键的符号，在内部可以直接使用回撤可以被识别，用于拼接字符串，或者在反引号的内部使用${xxx},xxx可以是变量或者是函数的调用。

12.数组方法，字符串方法，在es6总用来解决之前无法实现的效果。

13.es6 的定义函数与数组的新方法：大厅的格式，
let foo = (arg...) => {};

14.nodejs的模块化很强大，比如文件访问，网络访问，nodejs在web上应用广泛了。一个是系统模块，伴随node安装就全局安装在了系统中，还有文件模块，就是可以删掉文件后就失去功能，可以修改源代码。【os】使用os可以说的当前的操作，可以获得硬件的信息cpu。在开发中，可以require将模块引入，const os = require('os');引入os后才可以输出freemem，cpus，totalmem====还有一个模块四文件模块fs----var fs = require('fs');====接下来可以对文件的增删改查进行处理，mkdir，rmdir(可以有回调函数，只在出错无的时候才可以返回一堆信息)----writeFile，readFile，参数分别是多个，文件的名字与文件的内容，也有回调函数，表示了错误信息。第三个是对文件的路径进行解析，分别获取目录扩展名等。

15.除此之外，还有第三方的或者用户自定义的对象。最基本的原理就是require相当于是src的作用，可以把其他的代码拿过来用。里面的各种顶级兑现，都可以被调用出来。

16.require==src；return == module.exports。--使用技巧：分别是在一个模块文件中申明还批量的函数，在热河的地方，去吧这些函数加载在module.exports下的对象中去，这种方式是，在顶级对象下的所有可以访问的exports的内容也就是值，被定向的改变了，除此之外直接使用exports也可以实现暴露，不一样的是exports不可以被重新赋值，因为被访问到的是exports这个属性，那么，在exports下面去添加某些属性与方法也是可以的，但是注意的一点是不可以直接去修改值。

6.24node02=========================
1.相对路径以./----../----开头，绝对路径以cdef:/(window)或者/开头（linux），在浏览器引擎中，默认添加的是./以相对路径来表示，而在node中，有三种，前两种与上述一样，需要注意的是，/需要转义才可以使用，要不就会出现转义路劲中的第一个字母或数字，第三种是通过文件名的方式，在当前与当前之上的文件夹module_node，中去寻找。

2.require（）的依赖顺序的原则，首先是module_node目录下的该文件，接着是改名字为目录的文件夹，寻找下方有没有package.json文件，最后找到额是该名目录下的index文件。找到普通的文件直接返回一个对象，包括了所有的额函数与属性的键值对对象，在package中，查询的是main属性下的文件，也就是最后还是要找到一个文件可以自行的js文件，当引入一个多文件包的时候，main属性

3.模块的安装可以全局-g，也可以安装在当前文件夹下面，全局安装的也不一定就可以全局使用在网站，那是因为全局的安装却并一定有全局使用的功能，这个要看开发的包的功能。

4.在一个文件夹下面，创建独立文件夹，在内部打开窗口，npm init来添加json模板，绑定main文件，创建两个文件，通过多种方式互相连接，npm login--账号密码与邮箱，然后执行pulish

5.http：nodejs是一个运行环境，一般在服务端运行，nodejs应用分为两大部分，一个是作为语言，作为服务器的开发或者纯粹的后端实现，一个是作为工具，很少见到网站后端以node开发，一般是用来管理前端工程化工具。比如gulp，less，bower，webpack。

6.在node中可以使用http这是系统模块，创建http服务器，require('http')得到的是一个http对象，旗有很对的方法可以使用，最常用的是createServer来创建一个服务器，创建的这个实例监听一个端口，server.listen(数字比如80),这里监听的端口就是服务器的端口，只要没有被占用，都可以坚挺到，一般是3000，localhost:3000---这样的话就是访问我们创建的服务器，我们使用nodejs把js文件启动起来，再次输入域名与端口就看到在等待，shi还没事件，在js文件中，使用事件的on，格式----server.on('request',(req,res)=>{代码段})；触发的条件是是，每次执性请求触发，这里需要注意一点是，每次长期服务器，就会轻质一下那个刷醒一次页面，on事件参数有er，一个请求名字，一个回调函数，函数也有两个参数，第一个是request，第二个是response，一般来说，request显示在node窗口，而response显示在浏览器的页面，常用的是request.methos--url,header====response.write('xxxx');

7.原理方面，类似的，就是先创建一个顶级的依赖，http，在http下，有server、方法，server方法下面有多个方法，实现请求，同样的jq中的$.ajax----angular中的$http()----node中的require('http');除此之外，还有jq与angular中的链式编程。原理都是每一次调用，返回的都是一个元对象。

8.创建一个htm页面，实现一个账号与密码的submit，当然使用ajax也可以，主要是识别处理条件数据，返回的数据，如果是文字类型，必须注意使用content-type这个属性，他属于hear，就要设置在响应头中。res.headr(200,{'content-type':'text/html; charset=utf-8'}),那么，最重要的是请求的参数的获取与处理，原生啊ajax的参数是通过responseText对象处理，ajax是success，angular是then下的res.data来获取，而在node在中类似于php，php使用$_GET或，$_POST获取，zai node中使用require一个url文件，在下方设置获取的是url.parse(requist.url,true).query----node中对象的赋值是使用解构方便点，获取之后，返回的方式是res.write('这里直接使用上方的对象的键就可以')。

9.在nodejs语句中，获取get、的参数，就是通过require('url').parse(request.url,true).query == param----post的数据我们知道都是在header中设置的。npm init 默认吧当前文件夹作为模块名，创建了package.json文件，使用后台方法必须设置serverjs文件，同级的第三个文件夹的根目录，接着修改server文件，使用es6，创建一个http协议的依赖，在依赖下的方法createhttp，下的监听listen方法（端口，服务端监听成功的回调），并列的方法on，跟js中国的on绑定一致，也是使用函数绑定到request中。

10.所有的省略后缀的写法不可以加后缀，因为家里之后就是两个html

11.
6.25nodejs03===========================
1.请求发出的方式【地址栏有无参数--src与href--xmlhttprequest--表单的action】，然后服务器根据请求的类型返回不同的类型，浏览器又根据content-type解析不同的返回数据的类型，比如css，这种后缀不同的点。

6.27nodejs04============================
1.规范，amdcmd，commonjs，适用的分别是前端与后端。

2.如果开发者遵循了amd，必须要有defined，这不是依赖文件的规定，而是amd规定的，他的格式就是第一个参数是依赖的文件名，加引号的那李写自己 的文件名，第二个参数是回调。最为顶级函数，参数分别所依赖的文件的最顶级对象，作为参数，类似于jq的封装的顶级对象是jquery这样。----还有一种是cmd格式的，与amd的不同是defined的格式不一样，之后还有一点就是，两个都要用到requirejs这个模块加载器，模块加载的require位置不一样。amd的依赖require是在defined中完成的，cmd与commonjs中实在require中独立完成的。

3.使用send自尅使用一次，第二次是哪个在原理上出错。请求头的设置一定要在相应之前，在后端文件中，也是在返回一直数据之前，设置请求头header。

4.nodejs是ecma在node环境下的别名，将前端语言妆花为后端语言了，可以使用es6，也可以使用框架，而且不存在加载时间的问题。最新的技术就要使用在后台的技术中。

5.模板布局就是使用中间件，实现公共部分的重用。

6.28nodejs05==============================================
1.学习数据库mysql的写法，分别是使用增加（insert into 表（键1，键2，键3）value（值1，值2，值3） ）
删除（delete from 表 where ）----改（updata from）----查（select * form）；

2.在node中使用js实现数据库的查询方法是query，三个参数，第三个参数的形参data就是插叙语句最后返回的json对象，不是字符串，想要传给前端还要进行一次编码的encode。query方法的第一个参数是常见的query语句的识别但是第二个参数的作用就是在外边声明好的一个变量，存储在这个数组中，使用第一个参数的 查询条件的形式，问好？后面的条件占位符是放在数组中的。----let{name,age}={name:'xiaoni',age:12}  db.query('updata `users` set `name`=?,`age`=? where `id`=?',[name,age],(err,data) =>{ if(err)console.log(err);console.log(data)});-----需要注意的方法是问好的默认顺序就是后面的数组的前后填充的数据的顺序。对象的话，不需要在跟语句语句中使用=直接在第二个参数中使用=赋值的对象。

3.使用大量的字符串拼接不方便query识别语句，使用外部声明一个变量的方式，

4.require('mysql').query('sq;语句?',request.data,(err,data) =>{console.log(err);rep.send(data)});这一串命令就是：识别前端使用ajax传过来的data有get与post两种，nodejs识别后，讲其作为条件，执行nodejs的query方法，匹配mysql语句与这个参数，执行成功后的数据会整体传过来在data中、

5.祝福墙与个人博客的源码

6.30node06==========================================================
1.前端的模板引擎是arttemplate，后端使用的模板是xpl，这样的情况就是使用亲前后端的{{}}（这是定界符）冲突。express是后端框架，摆阔了很多的api。

2.使用moment插件可以实现时间的格式转换，就像使用localstrig这样。----子元素的maogin与padding继承的是父级元素的宽与高。

3.使用require（）这样返回的是哪个js文件或者json文件的最终返回值，或者是整个代码段，内部名称可以是一个映射名称，也可以是一个路径。

4.使用node，在某个mnode运行之后，对应的js文件启动，那么相应的listen启动，这个html文件就会相应的监听并启动，就不需要额外设置应用服务器。

5.启动服务器之后，网站需要交互并且需要手机信息，就要在数据库里面设置主键与字段，分别用英文设置好名（英文），类型（init纯数字，varchar字符串，数字字符char，01tinyint，编号数字字符char，文本text）

6。怎么实现注册，首先写一个路由，希望访问的是register页面，前端页面，在route下的homejs文件设置get这个页面，后端设置好xtpl，在后台页面根据nodejs写入文件，就要使用xtpl实现，前端是使用art，xtpl的模板添加格式是{{extend ./xxx}}继承摸个文件的模板，继承的点，设置的是{{# block}}中间添加的是{{/block}}

7.使用gulp的时候，使用过插件设置名称的后缀，使用注册信息的时候使用md5实现密文的加密，但是这样也是哟一定的不安全性，穷举爆破可以实现。

8.使用truncate ·users·用来清空数据。这样的作用是可以清空主键，下次的创建的主键是从1开始，这样的用法 在现实的情况下不使用，数据是宝贵的。

9.如果涉及到身份证之类的信息被提交之后，就不可以被用户继续修改。

10.use专门用来调用中间件的，凡是需要被use用来调用，就是中间件。

11.config配置，映射，静态页tpl或者换pages----js在public》script=====后端，controllers》modules》

7.1nodejs最后一天------------------

1.看到输入框要传到后端并去跟数据库去对比，第一件事情就是，前端的ajax，使用jquery的this。serialize（），前提是表单必须要有name属性，还有最下面要return false；阻止默认的跳转方式。

2.数据库的设计不会直接使用作者名字，其他也是，而是使用id的形式来存储可以被改变的东西来绑定某些专有性的东西。

3.使用前端的js与html先设置到静态资源，然后在新的页面中设置好相对的文件夹，在文件夹中分别设置好有意义的文件夹，把静态资源分别放在这里，这里只做页面的方式有两种，第一种是使用jq与arttemolate的格式，来实现页面的加载，或者使用php的include实现公共资源，这里也用到了路由，路由不是实现公共的部分，而是在访问一个文件的调价下，每次改变url，就对应不一样文件地址。这是前端渲染的格式，每次都是使用ajax实现，祸端获取数据，还是在arttemplate模板中去渲染数据，但是，在nodejs出现之后就出现了一个新的怨语言可以实现，后端语言es6，甚至是es7来回实现后端，因为后端不存在版本低的问题，开人员永远可以使用最新的版本来实现代码的编写，后端渲染的框架，基于nodejs的，xtpl，xtemplate，express，实现了路由routerappjs这个文件相当于之前的indexphp文件，在这里实现的根据跳转的路劲的path的不同可以选择不一样的问价来渲染页面，可以有数据也可以没有聚，因为是后端渲染，数据都是使用前端传过来的输入，在后盾nodejs文件中去根据匹配值去查询数据库的内容，或者是跟数据库去进行补充，在nodejs中使用xtpl就可以实现页面的渲染，核心就是使用----router实现单页面路由----模板实现渲染----后端直接操作数据库----获取前端的数据----在后端的gei或者post函数中使用query查询函数返回result----xtpl页面用定界符语句进行if挥着each，或者xindex设置好被渲染的变量result.xxx填充---

4.package。json的运行install必须是在dos中，在git版本中使用不会出来效果。

5,。使用模板的作用，最大的效果即使可以实现代码的精简，就是单个功能的页面只需要绑定到主页面{{extend ./xxx}}在单独的模板中使用{{#block（name1）}}这里是html代码段{{/block (name2)}}----{{#block}}这里是script的代码块{{/block}}然后在主页面中使用{{{}}}

5.1这里有一点需要注意，单纯的一个界定副的变量直接就可以接收script中的返回的value，但是使用一个代码打算的渲染就要使用三个。

6.查询某个数据库的对应的数据的方法就是，query语句，select ·pass·from 表名 where ？，接下来，在分装好的一个单独的js文件中国依赖过来，直接去调用分装好的额函数，参数不变，还是之前参数，第一个参数是query语句带着？，第二个参数是对象，可以是多个，放在数组中国，第三个就是函数的回调，分别有失败有成功后的返回值。

7.在模板中有一点要经常性的用到，就是存在性判断，在模板中国加载if定界符中的语句没有触发，html片段是不会显示出来的。

8.项目开发中尤其是遇到相似的功能，但是却需要不一样的代码显示，就要通过if判断来进行的到不一样的分支结构中，if判断只会，执行的就是公共的代码段。

9.对于res的返回值的操作，分别是render依赖于express

10跟多的时候，我们不可以直接不去还用query查数据库的语句，尤其是格式不对成或者名称键的值冲突的情况，就要在执行query之前去惊醒一个获取的前端的输入数据的处理，以便于在函数执行的过程中，可以成功。

11.前端修改就是输入----后端处理就是进行匹配----数据库进行增删改查就是输出。一个完整的流程，相反的，前端的请求---后端的处理----数据库的返回---后端的渲染，或者是前端请求数据后的渲染，就是三者之间的关系。

12.前端的技术分别是基于js的框架，类库，模板，插件，组件----后端的基本就是amd规范下的框架，类库，模板----就是去掉dom的js----数据库的使用跟多的是建表。

13.对应的一个键值对可以传到数据库的过程就是，前端的form表单的name值==请求data的对象的键，for表单的value，就是data数据的值，键值对在express的query方法中进行的匹配，就可以在参数中与query语句的？进行匹配，从而在数据库中进行了正常的检索，相似的，在前端请求后端的函数，只有一个返回值【data】----后端接收前端的函数有两个返回值，请求体【request】，与返回体【response】----后端与数据库的请求，数据库那边也有返回值分别是【成功状态数】----后端也有跟数据库的交互的返回值就是query犯法的【err】与【result】两个，通过在node环境中console.log(result)查看数组格式的数据库对象，而在-----前端查看后端返回的数据只能在浏览器的控制台查看console.log（xx）；

14.所有的函数都可以被封装，就像积木，----所有的同类的函数与功能都应该被放在一个模中，常见的模块的名称就像我么参见的类名一样重要。----前端插件就那么几个，但是后端的插件却很多，为什么后端一直使用数不胜数的插件。

14.一个技巧，如果给子元素直接添加一个事件，当绑定在父级元素的时候，实现的是自己与父点击的时候可以同时触发效果。

16.es6中的核心之一是Promise，可以解决异步嵌套的一种方案。es6总promise是一个构造函数，类似的还有（Date，Array同级别），这个newPromise的参数需要回到函数，回到函数的参数是固定的，创建的是一个成功与失败的函数的调用，相当于占位符，在外函数，使用当前函数的外层函数，闭包的原则，可以调用大这个函数，在调用者传入参数后，就可以用then（跟着成功）catch（跟着失败）。

17.第二种是模块化：目前的模块化浏览器与nodejs都不支持原生，

18.本来的在js中，如果使用script来实现所有的js都可以，但是有一点是，代码不能看，所以script都是根据功能分成了不同的js文件，如果太多，静态资源请求又过多了，但是想实现我只要一个script，但是有不影响我看我的代码，就可以使用类似于css的import的方法，就是在路由js我们去调用这一个而已，在路由js中，多个js文件有相互独立不干扰变量，但是相应的需要循环利用的，使用是雷雨暴露给window的方式，用module.exports来暴露给module来多文件调用。

19.那么问题来聊聊，怎么把我们写好的es6代码模块化转化为es5可以支持的代码.使用balel来转码，是nodejs开大的工具：1--全局安装balel-cli install balel-cli -g  2-当前文家目录下，设置.balelrc文件  3--进行配置a.

====================================
7.3vue01------------------------------
1哈希值的应用场景，一个使用在数字签名，就类似的文件图片不改变，他的文件名就不会变，文件改变就会不对应，在webpack的识别值的部分也用到了哈希值。

2.想要知道一个原理层面的知识，源码中，1，url地址，2.原生语法的组织。3.输出值。

3.使用图标字体的方法，一个是类名，一个是innertext。mui的原理是在css文件中的伪元素的content的值是一个对应的ttf格式中的一个文件。

4.\.转义符，/\.(jpg|png|ttf)$/这种样式是公用的，对于这种进制的不同导致的难以转化，就可以使用这样.去转化的原因是在css转化中识别不了这些格式。而不是故意为之

5.使用webpack都要进行配置的，默认的只是js，css要有加载器，html要有plugin

6.使用webpack压缩合并，遇到找不到文件包，但是包明明在，可能是上级文件路径不对或者是当前的文件夹中需要使用的是wenpack源文件，在全局的安装类似于环境变量的启动，在当前文件中抵用并安装文件的作用是因为我们要依赖他的源文件的代码。

7.学习的模式跟这目录结构就一样，先设置好模块化的学习标题，在大标题下填充该有的内容

7.4vue02=========================
1.当我们创建文件夹的时候，使用npm init -y 创建一个webpack.jason文件name自动识别当前文件夹。

2.线下环境使用npm run xxx，线上环境上线的时候需要使用bulild。

3.--port 0000后面跟着的短裤好，就是启动的服务器的端口号。

4.webpack的所有的属性，都是干什么的。要记住了。

5.:key=stu.id,用来计算单独的标识，不同于angular的自动识别，出现性能损耗。

6.wue组件的使用，
组件之间的通信，
router，
resource发起http、请求，
axios。

7.vue：2014开源，weex可以实现vue转为andriod与ioos

8.vue额绑定基于数据劫持，数据劫持的原理是使用在object.definePropety(obj,objname,get|set)实现set一个值，可以在get中获取到，并触发这个函数，在实际应用中要做到的是同步，就是用if判断，或者vaue的方法，获得收费。

9.使用resource实现数据的双向绑定。
10复习：当一天，全局的组件的声明vue.组件vue.component('组件名'，'组件对象')-->单文件的方式无法使用template页面中用到了text的地地方债更新。

7.6vue03=======================
1.监视锚点值的挂载，这个实现原理在angular于vue中全部都可以实现，首先，前提条件：1.创建一个页面.vue,2.设置一个对相应的路径地址。在实例化的vuerouter参数中一一设置好路径与引入的文件的（或别名）的对应跳转.起到链接作用的是

3.首先,thsi只有在调用的时候才可以确定,其次使用一个数组方法,把对穿进去,也可以实现,遍历.

4.实例化一个vue与实例化一个vuerouter,实现的都是在原型链上添加属性与方法.

5.实现框架性能与报错的平衡很那掌握,在完全正确下的模板中编写代码,但是除错误的话,就很难找到,.

6.route-link,是链接，在页面中必须用链接实先跳转页面而不是使用地址栏自己输入。链接的格式，之前是http、，或者是先对路劲，现在使用理由，使用锚点值#/可以保留链接的位置，基于路由额特点，必须是在路由中国选择性的加载这些页面。也就是看见#就有路由。或者css3总的target。

7.一个项目问题，router-link,没有匹配上名称。router-link--to=对象，按照名称name：‘xx’的鲈鱼规则来生成href，点你点击后，用当前的href匹配路由参数中的name键，就可以通过遍历，实现很多的链接。

8.当检索很多目录中的文件的时候，有一个目录不需要去检索，使用的而方法是api/outport/

9.路由的参数的转换，会出现，字符串类型与数字的转换，第一次的加载是数字，刷新后的匹配的成为字符串，第二次无效。

10.编程式，导航，程序代码改变锚点值。

11.在木跨化开发的vue中，可以在公公也设置样式，也可以在单独的页面设置类名与样式。这样可以在命名的组件上添加额外的组件，位置不练但是他的内容可以被替换。包括标签的那种替换

12.在每个组件中，单个的组件的style设置的属性，在全局上，可以被对应上就可以全局的改变，有时候会出现冲突的问题。解决的方案是在单页面的组件的style标签后面这只scoped值，没有属性值，就可以提高优先级，不会被覆盖。

13.vue的三大板块的注意点，template中只可以有一个顶级div，在style设置scoped解决顶级对象，在scripts固定模板export.dafult(){
	return data(){}
}

14.学习mui 的重点在于通过文档来找到用法，ok，在url地址找到对应的地址，ok，最后，在下载的包，找到pags中的文件名。去抽取代码，注意一点是，head的设置标签要放在index中。

15.关于模板的{{} }这里必须要有空格。

16.路由的哪里，怎么去，去了干嘛。
7.7vue04=================================
1.vue的目录结构，分别是index.html--app.vue--main.vue---main1.vue-mian2.vue-mian3.vue

2.mainjs是一个中心文件，在condigjs中分别是所有的，
3.开发的实现，先在一个静态的页面中看待他的运行的效果，实现了效果就开始在vue这样的文件中进行填充。

4.所有的实际开发中使用到的存在性判断，if判断可以实现。

5.vue的学习路线，显示api，接着是dome，最后在小项目中实现demo。

6.v-bind是单向，v-text也是单向，只有v-model是双向的。

7.18react03===================
1.使用index。html作为一个母版，使用js文件中写标签的方式添加到母版，使用
	</p>
</body>
</html>